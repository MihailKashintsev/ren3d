<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ren3D</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Syne:wght@400;500;600;700;800&family=Fira+Code:wght@300;400;500&display=swap');

        :root {
            --void: #050508;
            --glass-bg: rgba(255,255,255,0.04);
            --glass-bg-hover: rgba(255,255,255,0.07);
            --glass-border: rgba(255,255,255,0.08);
            --glass-border-active: rgba(255,255,255,0.18);
            --glass-shadow: 0 8px 32px rgba(0,0,0,0.5);
            --blur: blur(20px);
            --blur-sm: blur(12px);
            --ink: rgba(255,255,255,0.92);
            --ink-mid: rgba(255,255,255,0.45);
            --ink-dim: rgba(255,255,255,0.18);
            --ink-ghost: rgba(255,255,255,0.07);
            --cyan: #00d4ff;
            --cyan-dim: rgba(0,212,255,0.15);
            --cyan-glow: 0 0 20px rgba(0,212,255,0.35);
            --orange: #ff6b35;
            --orange-dim: rgba(255,107,53,0.15);
            --green: #39ff8f;
            --red: #ff4466;
            --purple: #b78bff;
            --yellow: #ffe066;
            --ax: #ff5566;
            --ay: #44ff88;
            --az: #4499ff;
            --panel-w: 220px;
            --topbar-h: 44px;
            --statusbar-h: 22px;
            --r: 10px;
            --r-sm: 6px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: var(--void);
            color: var(--ink);
            font-family: 'Fira Code', monospace;
            font-size: 11px;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            cursor: default;
        }

            /* ‚îÄ‚îÄ NOISE GRAIN OVERLAY ‚îÄ‚îÄ */
            body::before {
                content: '';
                position: fixed;
                inset: 0;
                background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.04'/%3E%3C/svg%3E");
                pointer-events: none;
                z-index: 9999;
                opacity: 0.6;
            }

            /* ‚îÄ‚îÄ GRID BG ‚îÄ‚îÄ */
            body::after {
                content: '';
                position: fixed;
                inset: 0;
                background-image: linear-gradient(rgba(255,255,255,0.025) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.025) 1px, transparent 1px);
                background-size: 40px 40px;
                pointer-events: none;
                z-index: 0;
            }

        /* ‚îÄ‚îÄ LAYOUT ‚îÄ‚îÄ */
        #app {
            position: fixed;
            inset: 0;
            display: grid;
            grid-template-rows: var(--topbar-h) 1fr var(--statusbar-h);
            grid-template-columns: var(--panel-w) 1fr var(--panel-w);
            z-index: 1;
        }

        /* ‚îÄ‚îÄ GLASS PANEL BASE ‚îÄ‚îÄ */
        .glass {
            background: var(--glass-bg);
            backdrop-filter: var(--blur);
            -webkit-backdrop-filter: var(--blur);
            border: 1px solid var(--glass-border);
        }

        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
           TOPBAR
        ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        #topbar {
            grid-column: 1 / -1;
            background: rgba(5,5,8,0.85);
            backdrop-filter: var(--blur);
            -webkit-backdrop-filter: var(--blur);
            border-bottom: 1px solid var(--glass-border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 6px;
            position: relative;
            z-index: 100;
        }

        .logo {
            font-family: 'Syne', sans-serif;
            font-size: 15px;
            font-weight: 800;
            letter-spacing: 0.12em;
            color: var(--cyan);
            text-shadow: var(--cyan-glow);
            margin-right: 12px;
            display: flex;
            align-items: center;
            gap: 7px;
        }

        .logo-mark {
            width: 22px;
            height: 22px;
            border: 2px solid var(--cyan);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            box-shadow: var(--cyan-glow), inset 0 0 8px rgba(0,212,255,0.1);
            animation: logoBreath 3s ease-in-out infinite;
        }

        @keyframes logoBreath {
            0%,100% {
                box-shadow: var(--cyan-glow), inset 0 0 8px rgba(0,212,255,0.1);
            }

            50% {
                box-shadow: 0 0 30px rgba(0,212,255,0.5), inset 0 0 12px rgba(0,212,255,0.15);
            }
        }

        .menu-wrap {
            position: relative;
        }

        .menu-trigger {
            padding: 5px 10px;
            background: transparent;
            border: 1px solid transparent;
            border-radius: var(--r-sm);
            color: var(--ink-mid);
            cursor: pointer;
            font-family: 'Fira Code', monospace;
            font-size: 11px;
            transition: all 0.15s;
            white-space: nowrap;
        }

            .menu-trigger:hover {
                background: var(--glass-bg);
                border-color: var(--glass-border);
                color: var(--ink);
            }

            .menu-trigger.open {
                background: var(--glass-bg-hover);
                border-color: var(--glass-border-active);
                color: var(--ink);
            }

        .dropdown {
            position: absolute;
            top: calc(100% + 6px);
            left: 0;
            background: rgba(8,8,14,0.95);
            backdrop-filter: var(--blur);
            border: 1px solid var(--glass-border-active);
            border-radius: var(--r);
            min-width: 210px;
            z-index: 999;
            display: none;
            padding: 5px;
            box-shadow: 0 16px 48px rgba(0,0,0,0.8), 0 0 1px rgba(255,255,255,0.05);
        }

            .dropdown.open {
                display: block;
                animation: dropIn 0.15s ease;
            }

        @keyframes dropIn {
            from {
                opacity: 0;
                transform: translateY(-4px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .dd-item {
            padding: 6px 10px;
            cursor: pointer;
            border-radius: var(--r-sm);
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--ink-mid);
            transition: all 0.1s;
            font-size: 11px;
        }

            .dd-item:hover {
                background: var(--glass-bg-hover);
                color: var(--ink);
            }

            .dd-item .ks {
                color: var(--ink-dim);
                font-size: 10px;
            }

        .dd-sep {
            height: 1px;
            background: var(--glass-border);
            margin: 4px 0;
        }

        .tb-sep {
            width: 1px;
            height: 18px;
            background: var(--glass-border);
            margin: 0 4px;
        }

        .spacer {
            flex: 1;
        }

        /* Tool buttons */
        .tb-group {
            display: flex;
            gap: 2px;
        }

        .tb-btn {
            width: 30px;
            height: 28px;
            background: transparent;
            border: 1px solid transparent;
            border-radius: var(--r-sm);
            color: var(--ink-mid);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            transition: all 0.15s;
            position: relative;
        }

            .tb-btn:hover {
                background: var(--glass-bg);
                color: var(--ink);
                border-color: var(--glass-border);
            }

            .tb-btn.active {
                background: var(--cyan-dim);
                color: var(--cyan);
                border-color: rgba(0,212,255,0.3);
                box-shadow: 0 0 10px rgba(0,212,255,0.2);
            }

        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
           LEFT PANEL
        ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        #left {
            background: rgba(5,5,8,0.7);
            backdrop-filter: var(--blur);
            border-right: 1px solid var(--glass-border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-title {
            font-family: 'Syne', sans-serif;
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            color: var(--ink-dim);
            padding: 10px 12px 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* PRIMITIVES */
        .prim-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 3px;
            padding: 0 8px 8px;
        }

        .prim-btn {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: var(--r-sm);
            padding: 8px 4px 6px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            color: var(--ink-mid);
            transition: all 0.2s;
            font-family: 'Fira Code', monospace;
            font-size: 9px;
        }

            .prim-btn:hover {
                background: var(--glass-bg-hover);
                border-color: var(--glass-border-active);
                color: var(--ink);
                transform: translateY(-1px);
                box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            }

            .prim-btn:active {
                transform: translateY(0);
            }

        .prim-ico {
            font-size: 18px;
            line-height: 1;
        }

        .panel-div {
            height: 1px;
            background: var(--glass-border);
            margin: 2px 8px 6px;
        }

        /* SCENE TREE */
        #tree-wrap {
            flex: 1;
            overflow-y: auto;
            padding: 0 4px 4px;
        }

            #tree-wrap::-webkit-scrollbar {
                width: 3px;
            }

            #tree-wrap::-webkit-scrollbar-thumb {
                background: var(--ink-ghost);
                border-radius: 2px;
            }

        .tree-node {
            padding: 5px 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            color: var(--ink-mid);
            border-radius: var(--r-sm);
            transition: all 0.1s;
            position: relative;
        }

            .tree-node:hover {
                background: var(--glass-bg);
                color: var(--ink);
            }

            .tree-node.sel {
                background: var(--cyan-dim);
                color: var(--cyan);
                border: 1px solid rgba(0,212,255,0.2);
            }

            .tree-node .tn-ico {
                font-size: 10px;
                opacity: 0.6;
            }

            .tree-node .tn-name {
                flex: 1;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            .tree-node .tn-eye {
                opacity: 0;
                width: 14px;
                font-size: 10px;
                transition: opacity 0.1s;
            }

            .tree-node:hover .tn-eye {
                opacity: 1;
            }

            .tree-node.hidden-obj {
                opacity: 0.35;
            }

        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
           VIEWPORT
        ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        #vp {
            position: relative;
            overflow: hidden;
            background: var(--void);
        }

        #c3d {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Viewport UI elements */
        .vp-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        .vp-corner-tl {
            position: absolute;
            top: 14px;
            left: 14px;
            font-size: 10px;
            color: var(--ink-dim);
        }

        .vp-cam-label {
            position: absolute;
            top: 14px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(5,5,8,0.7);
            backdrop-filter: var(--blur-sm);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 4px 14px;
            font-size: 10px;
            color: var(--ink-mid);
            pointer-events: none;
            white-space: nowrap;
        }

        /* TRANSFORM MODE TOOLBAR - floating in viewport */
        #tm-bar {
            position: absolute;
            top: 14px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 2px;
            background: rgba(5,5,8,0.82);
            backdrop-filter: var(--blur-sm);
            border: 1px solid var(--glass-border);
            border-radius: 30px;
            padding: 4px;
            pointer-events: all;
            z-index: 10;
        }

        .tm-btn {
            width: 34px;
            height: 26px;
            background: transparent;
            border: 1px solid transparent;
            border-radius: 20px;
            color: var(--ink-mid);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.15s;
            font-family: 'Fira Code', monospace;
            font-size: 10px;
            gap: 3px;
        }

            .tm-btn:hover {
                background: var(--glass-bg);
                color: var(--ink);
            }

            .tm-btn.active {
                background: var(--cyan-dim);
                color: var(--cyan);
                border-color: rgba(0,212,255,0.3);
            }

        /* Empty hint */
        #empty-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            color: var(--ink-dim);
            font-size: 11px;
            line-height: 2.2;
        }

        .eh-icon {
            font-size: 40px;
            margin-bottom: 8px;
            opacity: 0.2;
        }

        .eh-key {
            color: var(--cyan);
            opacity: 0.7;
        }

        /* GIZMO */
        #gizmo-cnv {
            position: absolute;
            bottom: 16px;
            right: 16px;
            width: 72px;
            height: 72px;
            pointer-events: none;
        }

        /* Stats */
        #vp-stats {
            position: absolute;
            bottom: 14px;
            left: 14px;
            font-size: 10px;
            color: var(--ink-dim);
            pointer-events: none;
        }

        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
           RIGHT PANEL
        ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        #right {
            background: rgba(5,5,8,0.7);
            backdrop-filter: var(--blur);
            border-left: 1px solid var(--glass-border);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

            #right::-webkit-scrollbar {
                width: 3px;
            }

            #right::-webkit-scrollbar-thumb {
                background: var(--ink-ghost);
                border-radius: 2px;
            }

        /* No selection */
        #no-sel {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--ink-dim);
            font-size: 11px;
            text-align: center;
            gap: 8px;
            padding: 20px;
        }

        .nosel-ico {
            font-size: 32px;
            opacity: 0.15;
        }

        /* Props */
        .prop-sec {
            border-bottom: 1px solid var(--glass-border);
        }

        .sec-head {
            padding: 8px 12px;
            font-family: 'Syne', sans-serif;
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            color: var(--ink-dim);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: color 0.1s;
        }

            .sec-head:hover {
                color: var(--ink-mid);
            }

            .sec-head .chev {
                transition: transform 0.2s;
                font-style: normal;
            }

            .sec-head.coll .chev {
                transform: rotate(-90deg);
            }

        .sec-body {
            padding: 4px 10px 10px;
        }

        /* Vec3 row */
        .plabel {
            font-size: 9px;
            color: var(--ink-dim);
            letter-spacing: 0.1em;
            text-transform: uppercase;
            margin-bottom: 4px;
            margin-top: 4px;
        }

        .v3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 3px;
            margin-bottom: 4px;
        }

        .vf {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

            .vf label {
                font-size: 9px;
                padding-left: 3px;
                letter-spacing: 0.05em;
            }

                .vf label.lx {
                    color: var(--ax);
                }

                .vf label.ly {
                    color: var(--ay);
                }

                .vf label.lz {
                    color: var(--az);
                }

        .ni {
            background: rgba(255,255,255,0.04);
            border: 1px solid var(--glass-border);
            border-radius: var(--r-sm);
            color: var(--ink);
            font-family: 'Fira Code', monospace;
            font-size: 10px;
            padding: 4px 5px;
            width: 100%;
            text-align: center;
            transition: border-color 0.15s, background 0.15s;
            outline: none;
        }

            .ni:hover {
                border-color: var(--glass-border-active);
            }

            .ni:focus {
                border-color: rgba(0,212,255,0.5);
                background: rgba(0,212,255,0.04);
            }

        /* Color */
        .cr {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }

        .ci {
            width: 30px;
            height: 22px;
            border: 1px solid var(--glass-border);
            border-radius: var(--r-sm);
            padding: 2px;
            background: transparent;
            cursor: pointer;
        }

        .cl {
            color: var(--ink-mid);
            font-size: 11px;
        }

        /* Range */
        .rr {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
        }

            .rr label {
                color: var(--ink-mid);
                font-size: 10px;
                min-width: 58px;
            }

        .ri {
            flex: 1;
            accent-color: var(--cyan);
            cursor: pointer;
            height: 3px;
        }

        .rv {
            color: var(--ink-mid);
            font-size: 10px;
            min-width: 28px;
            text-align: right;
        }

        /* Toggle */
        .tr {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 5px;
        }

            .tr label {
                color: var(--ink-mid);
                font-size: 11px;
            }

        .tog {
            width: 28px;
            height: 14px;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
        }

            .tog.on {
                background: rgba(0,212,255,0.25);
                border-color: rgba(0,212,255,0.5);
            }

            .tog::after {
                content: '';
                position: absolute;
                width: 10px;
                height: 10px;
                background: var(--ink-dim);
                border-radius: 50%;
                top: 1px;
                left: 1px;
                transition: transform 0.2s, background 0.2s;
            }

            .tog.on::after {
                transform: translateX(14px);
                background: var(--cyan);
            }

        /* Boolean ops */
        .bool-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 4px;
        }

        .bool-btn {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: var(--r-sm);
            padding: 8px 2px;
            cursor: pointer;
            color: var(--ink-mid);
            font-family: 'Fira Code', monospace;
            font-size: 9px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            transition: all 0.2s;
        }

            .bool-btn:hover {
                background: var(--glass-bg-hover);
                border-color: var(--glass-border-active);
                color: var(--ink);
                transform: translateY(-1px);
            }

            .bool-btn .bi {
                font-size: 18px;
            }

        .bool-hint {
            font-size: 9px;
            color: var(--ink-dim);
            margin-bottom: 6px;
            line-height: 1.5;
        }

        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
           STATUS BAR
        ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        #statusbar {
            grid-column: 1 / -1;
            background: rgba(5,5,8,0.9);
            border-top: 1px solid var(--glass-border);
            display: flex;
            align-items: center;
            padding: 0 12px;
            gap: 14px;
            font-size: 10px;
            color: var(--ink-dim);
        }

        .si {
            display: flex;
            gap: 4px;
        }

            .si span {
                color: var(--ink-mid);
            }

        .ss {
            color: var(--glass-border);
        }

        .kbd {
            display: inline-block;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 3px;
            padding: 0 4px;
            font-size: 9px;
            color: var(--ink-dim);
        }

        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
           MODALS & TOASTS
        ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        .modal-bg {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            backdrop-filter: var(--blur-sm);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-box {
            background: rgba(8,8,14,0.95);
            border: 1px solid var(--glass-border-active);
            border-radius: 14px;
            padding: 24px;
            min-width: 340px;
            box-shadow: 0 24px 80px rgba(0,0,0,0.9);
            animation: dropIn 0.2s ease;
        }

            .modal-box h3 {
                font-family: 'Syne', sans-serif;
                font-size: 14px;
                font-weight: 700;
                color: var(--ink);
                margin-bottom: 10px;
            }

            .modal-box p {
                color: var(--ink-mid);
                font-size: 11px;
                line-height: 1.7;
                margin-bottom: 16px;
            }

        .modal-btns {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .mbtn {
            padding: 7px 18px;
            border-radius: var(--r-sm);
            border: 1px solid var(--glass-border);
            background: var(--glass-bg);
            color: var(--ink-mid);
            cursor: pointer;
            font-family: 'Fira Code', monospace;
            font-size: 11px;
            transition: all 0.15s;
        }

            .mbtn:hover {
                background: var(--glass-bg-hover);
                color: var(--ink);
                border-color: var(--glass-border-active);
            }

            .mbtn.primary {
                background: var(--cyan-dim);
                border-color: rgba(0,212,255,0.4);
                color: var(--cyan);
            }

                .mbtn.primary:hover {
                    background: rgba(0,212,255,0.25);
                }

        #toast {
            position: fixed;
            bottom: 36px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(8,8,14,0.92);
            backdrop-filter: var(--blur-sm);
            border: 1px solid var(--glass-border-active);
            border-radius: 30px;
            padding: 7px 20px;
            font-size: 11px;
            color: var(--ink);
            z-index: 5000;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            transition: opacity 0.4s;
            pointer-events: none;
            white-space: nowrap;
        }

        /* Context menu */
        .ctx {
            position: fixed;
            background: rgba(8,8,14,0.95);
            backdrop-filter: var(--blur);
            border: 1px solid var(--glass-border-active);
            border-radius: var(--r);
            padding: 5px;
            z-index: 3000;
            min-width: 170px;
            box-shadow: 0 16px 48px rgba(0,0,0,0.8);
            animation: dropIn 0.12s ease;
        }

        .ctx-it {
            padding: 6px 10px;
            cursor: pointer;
            border-radius: var(--r-sm);
            color: var(--ink-mid);
            font-size: 11px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.1s;
        }

            .ctx-it:hover {
                background: var(--glass-bg-hover);
                color: var(--ink);
            }

            .ctx-it.danger {
                color: var(--red);
            }

                .ctx-it.danger:hover {
                    background: rgba(255,68,102,0.1);
                }

        .ctx-sep {
            height: 1px;
            background: var(--glass-border);
            margin: 3px 0;
        }

        /* scrollbar global */
        ::-webkit-scrollbar {
            width: 4px;
            height: 4px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--ink-ghost);
            border-radius: 2px;
        }

        input[type=file] {
            display: none;
        }

        /* ‚îÄ‚îÄ RESIZABLE PANELS ‚îÄ‚îÄ */
        .panel-resize-handle {
            width: 4px;
            cursor: col-resize;
            background: transparent;
            transition: background 0.2s;
            z-index: 10;
            flex-shrink: 0;
            position: relative;
        }

            .panel-resize-handle:hover, .panel-resize-handle.dragging {
                background: rgba(0,212,255,0.35);
            }

        #app {
            grid-template-columns: var(--panel-w) 1fr var(--panel-w);
        }

        /* ‚îÄ‚îÄ RENAME INPUT ‚îÄ‚îÄ */
        .tree-node .tn-rename {
            flex: 1;
            background: rgba(0,212,255,0.08);
            border: 1px solid rgba(0,212,255,0.4);
            border-radius: 4px;
            color: var(--cyan);
            font-family: 'Fira Code', monospace;
            font-size: 10px;
            padding: 1px 4px;
            outline: none;
            min-width: 0;
        }

        /* ‚îÄ‚îÄ EXPORT MODAL ‚îÄ‚îÄ */
        .exp-opt {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border-radius: var(--r-sm);
            border: 1px solid var(--glass-border);
            background: var(--glass-bg);
            cursor: pointer;
            margin-bottom: 6px;
            transition: all 0.15s;
            color: var(--ink-mid);
        }

            .exp-opt:hover {
                background: var(--glass-bg-hover);
                border-color: var(--glass-border-active);
                color: var(--ink);
            }

            .exp-opt .eo-ico {
                font-size: 20px;
            }

            .exp-opt .eo-title {
                font-family: 'Syne', sans-serif;
                font-size: 12px;
                font-weight: 600;
                color: var(--ink);
            }

            .exp-opt .eo-desc {
                font-size: 9px;
                color: var(--ink-dim);
            }

        /* ‚îÄ‚îÄ OBJECT NAME in inspector ‚îÄ‚îÄ */
        #obj-name-input {
            width: 100%;
            background: rgba(255,255,255,0.04);
            border: 1px solid var(--glass-border);
            border-radius: var(--r-sm);
            color: var(--ink);
            font-family: 'Fira Code', monospace;
            font-size: 11px;
            padding: 5px 8px;
            outline: none;
            transition: border-color 0.15s;
            margin-bottom: 2px;
        }

            #obj-name-input:focus {
                border-color: rgba(0,212,255,0.5);
                background: rgba(0,212,255,0.04);
            }
    </style>
</head>
<body>
    <div id="app">

        <!-- ‚ïê‚ïê‚ïê TOPBAR ‚ïê‚ïê‚ïê -->
        <div id="topbar">
            <div class="logo">
                <div class="logo-mark">R</div>
                REN3D
            </div>

            <div class="menu-wrap">
                <button class="menu-trigger" onclick="openMenu('file',this)">–§–∞–π–ª</button>
                <div class="dropdown" id="dd-file">
                    <div class="dd-item" onclick="newScene()">–ù–æ–≤–∞—è —Å—Ü–µ–Ω–∞ <span class="ks">Ctrl+N</span></div>
                    <div class="dd-sep"></div>
                    <div class="dd-item" onclick="saveProject()">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—Ä–æ–µ–∫—Ç <span class="ks">Ctrl+S</span></div>
                    <div class="dd-item" onclick="openProject()">–û—Ç–∫—Ä—ã—Ç—å –ø—Ä–æ–µ–∫—Ç <span class="ks">Ctrl+O</span></div>
                    <div class="dd-sep"></div>
                    <div class="dd-item" onclick="doImport()">–ò–º–ø–æ—Ä—Ç .stl/.obj <span class="ks">Ctrl+I</span></div>
                    <div class="dd-sep"></div>
                    <div class="dd-item" onclick="showExportModal()">–≠–∫—Å–ø–æ—Ä—Ç... <span class="ks">Ctrl+E</span></div>
                </div>
            </div>

            <div class="menu-wrap">
                <button class="menu-trigger" onclick="openMenu('edit',this)">–ü—Ä–∞–≤–∫–∞</button>
                <div class="dropdown" id="dd-edit">
                    <div class="dd-item" onclick="undo()">–û—Ç–º–µ–Ω–∞ <span class="ks">Ctrl+Z</span></div>
                    <div class="dd-item" onclick="redo()">–ü–æ–≤—Ç–æ—Ä <span class="ks">Ctrl+Y</span></div>
                    <div class="dd-sep"></div>
                    <div class="dd-item" onclick="duplicateSel()">–î—É–±–ª–∏—Ä–æ–≤–∞—Ç—å <span class="ks">Ctrl+D</span></div>
                    <div class="dd-item" onclick="deleteSel()">–£–¥–∞–ª–∏—Ç—å <span class="ks">Del</span></div>
                    <div class="dd-sep"></div>
                    <div class="dd-item" onclick="selectAll()">–í—ã–¥–µ–ª–∏—Ç—å –≤—Å—ë <span class="ks">Ctrl+A</span></div>
                    <div class="dd-item" onclick="deselectAll()">–°–Ω—è—Ç—å –≤—ã–¥–µ–ª–µ–Ω–∏–µ <span class="ks">Esc</span></div>
                </div>
            </div>

            <div class="menu-wrap">
                <button class="menu-trigger" onclick="openMenu('view',this)">–í–∏–¥</button>
                <div class="dropdown" id="dd-view">
                    <div class="dd-item" onclick="camView('persp')">–ü–µ—Ä—Å–ø–µ–∫—Ç–∏–≤–∞ <span class="ks">Num 5</span></div>
                    <div class="dd-item" onclick="camView('front')">–°–ø–µ—Ä–µ–¥–∏ <span class="ks">Num 1</span></div>
                    <div class="dd-item" onclick="camView('top')">–°–≤–µ—Ä—Ö—É <span class="ks">Num 7</span></div>
                    <div class="dd-item" onclick="camView('right')">–°–ø—Ä–∞–≤–∞ <span class="ks">Num 3</span></div>
                    <div class="dd-sep"></div>
                    <div class="dd-item" onclick="frameAll()">–ü–æ–∫–∞–∑–∞—Ç—å –≤—Å—ë <span class="ks">Home</span></div>
                    <div class="dd-item" onclick="frameSel()">–ü–æ–∫–∞–∑–∞—Ç—å –≤—ã–±—Ä–∞–Ω–Ω–æ–µ <span class="ks">F</span></div>
                    <div class="dd-sep"></div>
                    <div class="dd-item" onclick="toggleGrid()">–°–µ—Ç–∫–∞ <span class="ks">G</span></div>
                    <div class="dd-item" onclick="toggleWire()">–ö–∞—Ä–∫–∞—Å <span class="ks">Z</span></div>
                </div>
            </div>

            <div class="menu-wrap">
                <button class="menu-trigger" onclick="openMenu('add',this)">–î–æ–±–∞–≤–∏—Ç—å</button>
                <div class="dropdown" id="dd-add">
                    <div class="dd-item" onclick="addObj('box')">‚¨õ –ö—É–± <span class="ks">Shift+C</span></div>
                    <div class="dd-item" onclick="addObj('sphere')">üîµ –°—Ñ–µ—Ä–∞ <span class="ks">Shift+S</span></div>
                    <div class="dd-item" onclick="addObj('cyl')">üî∑ –¶–∏–ª–∏–Ω–¥—Ä <span class="ks">Shift+Y</span></div>
                    <div class="dd-item" onclick="addObj('cone')">üî∫ –ö–æ–Ω—É—Å <span class="ks">Shift+O</span></div>
                    <div class="dd-item" onclick="addObj('torus')">‚≠ï –¢–æ—Ä <span class="ks">Shift+T</span></div>
                    <div class="dd-item" onclick="addObj('plane')">‚¨ú –ü–ª–æ—Å–∫–æ—Å—Ç—å <span class="ks">Shift+P</span></div>
                </div>
            </div>

            <div class="tb-sep"></div>

            <div class="tb-group">
                <button class="tb-btn active" id="tbb-sel" title="–í—ã–±–æ—Ä (Q)" onclick="setTool('sel')">‚ú¶</button>
                <button class="tb-btn" id="tbb-move" title="–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ (G)" onclick="setTool('move')">‚ú•</button>
                <button class="tb-btn" id="tbb-rot" title="–í—Ä–∞—â–µ–Ω–∏–µ (R)" onclick="setTool('rot')">‚Üª</button>
                <button class="tb-btn" id="tbb-scale" title="–ú–∞—Å—à—Ç–∞–± (S)" onclick="setTool('scale')">‚äû</button>
            </div>

            <div class="tb-sep"></div>

            <div class="tb-group">
                <button class="tb-btn" title="–ù–æ–≤–∞—è —Å—Ü–µ–Ω–∞" onclick="newScene()">üóã</button>
                <button class="tb-btn" title="–ò–º–ø–æ—Ä—Ç (Ctrl+I)" onclick="doImport()">‚á™</button>
                <button class="tb-btn" title="–≠–∫—Å–ø–æ—Ä—Ç (Ctrl+E)" onclick="showExportModal()">‚á©</button>
            </div>

            <div class="spacer"></div>
            <div style="font-size:10px;color:var(--ink-dim)">–†–µ–∂–∏–º: <span id="mode-lbl" style="color:var(--cyan)">–û–±—ä–µ–∫—Ç</span></div>
        </div>

        <!-- ‚ïê‚ïê‚ïê LEFT PANEL ‚ïê‚ïê‚ïê -->
        <div id="left">
            <div class="panel-title">–ü—Ä–∏–º–∏—Ç–∏–≤—ã</div>
            <div class="prim-grid">
                <button class="prim-btn" onclick="addObj('box')"><span class="prim-ico">‚¨õ</span>–ö—É–±</button>
                <button class="prim-btn" onclick="addObj('sphere')"><span class="prim-ico">üîµ</span>–°—Ñ–µ—Ä–∞</button>
                <button class="prim-btn" onclick="addObj('cyl')"><span class="prim-ico">üî∑</span>–¶–∏–ª–∏–Ω–¥—Ä</button>
                <button class="prim-btn" onclick="addObj('cone')"><span class="prim-ico">üî∫</span>–ö–æ–Ω—É—Å</button>
                <button class="prim-btn" onclick="addObj('torus')"><span class="prim-ico">‚≠ï</span>–¢–æ—Ä</button>
                <button class="prim-btn" onclick="addObj('plane')"><span class="prim-ico">‚¨ú</span>–ü–ª–æ—Å–∫–æ—Å—Ç—å</button>
            </div>
            <div class="panel-div"></div>
            <div class="panel-title">
                –°—Ü–µ–Ω–∞
                <span id="obj-cnt" style="font-family:'Fira Code';font-size:9px;font-weight:400;letter-spacing:0;text-transform:none">0</span>
            </div>
            <div id="tree-wrap"></div>
        </div>

        <!-- ‚ïê‚ïê‚ïê VIEWPORT ‚ïê‚ïê‚ïê -->
        <div id="vp">
            <canvas id="c3d"></canvas>

            <div id="tm-bar">
                <button class="tm-btn active" id="tmb-none" onclick="setGizmoMode('none')" title="–í—ã–±–æ—Ä (Q)">‚ú¶ –í—ã–±–æ—Ä</button>
                <button class="tm-btn" id="tmb-translate" onclick="setGizmoMode('translate')" title="–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ (G)">‚ú• Move</button>
                <button class="tm-btn" id="tmb-rotate" onclick="setGizmoMode('rotate')" title="–í—Ä–∞—â–µ–Ω–∏–µ (R)">‚Üª Rot</button>
                <button class="tm-btn" id="tmb-scale" onclick="setGizmoMode('scale')" title="–ú–∞—Å—à—Ç–∞–± (S)">‚äû Scale</button>
            </div>

            <div id="empty-hint">
                <div class="eh-icon">‚óà</div>
                –°—Ü–µ–Ω–∞ –ø—É—Å—Ç–∞<br>
                <span class="eh-key">Shift+C</span> ‚Äî –ö—É–± &nbsp;
                <span class="eh-key">Shift+S</span> ‚Äî –°—Ñ–µ—Ä–∞<br>
                <span class="eh-key">Ctrl+I</span> ‚Äî –ò–º–ø–æ—Ä—Ç &nbsp;
                <span class="eh-key">–ü–ö–ú</span> ‚Äî –û—Ä–±–∏—Ç–∞
            </div>

            <canvas id="gizmo-cnv" width="72" height="72"></canvas>
            <div id="vp-stats">–û–±—ä–µ–∫—Ç–æ–≤: 0 | –¢—Ä–∏—Å: 0</div>
        </div>

        <!-- ‚ïê‚ïê‚ïê RIGHT PANEL ‚ïê‚ïê‚ïê -->
        <div id="right">
            <div id="no-sel">
                <div class="nosel-ico">‚óà</div>
                <span style="color:var(--ink-dim)">–ù–∏—á–µ–≥–æ –Ω–µ –≤—ã–±—Ä–∞–Ω–æ</span>
                <span style="color:var(--ink-ghost);font-size:10px">–ö–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ –æ–±—ä–µ–∫—Ç</span>
            </div>

            <div id="props" style="display:none">

                <!-- Object Name -->
                <div style="padding: 8px 10px 4px;">
                    <input id="obj-name-input" type="text" placeholder="–ù–∞–∑–≤–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞" onchange="applyObjName()" onblur="applyObjName()">
                </div>

                <!-- Transform -->
                <div class="prop-sec">
                    <div class="sec-head" onclick="toggleSec(this)">–¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è <i class="chev">‚ñæ</i></div>
                    <div class="sec-body">
                        <div class="plabel">–ü–æ–∑–∏—Ü–∏—è</div>
                        <div class="v3">
                            <div class="vf"><label class="lx">X</label><input class="ni" id="px" type="number" step="0.1" onchange="applyTf()"></div>
                            <div class="vf"><label class="ly">Y</label><input class="ni" id="py" type="number" step="0.1" onchange="applyTf()"></div>
                            <div class="vf"><label class="lz">Z</label><input class="ni" id="pz" type="number" step="0.1" onchange="applyTf()"></div>
                        </div>
                        <div class="plabel">–í—Ä–∞—â–µ–Ω–∏–µ ¬∞</div>
                        <div class="v3">
                            <div class="vf"><label class="lx">X</label><input class="ni" id="rx" type="number" step="1" onchange="applyTf()"></div>
                            <div class="vf"><label class="ly">Y</label><input class="ni" id="ry" type="number" step="1" onchange="applyTf()"></div>
                            <div class="vf"><label class="lz">Z</label><input class="ni" id="rz" type="number" step="1" onchange="applyTf()"></div>
                        </div>
                        <div class="plabel">–ú–∞—Å—à—Ç–∞–±</div>
                        <div class="v3">
                            <div class="vf"><label class="lx">X</label><input class="ni" id="sx" type="number" step="0.1" onchange="applyTf()"></div>
                            <div class="vf"><label class="ly">Y</label><input class="ni" id="sy" type="number" step="0.1" onchange="applyTf()"></div>
                            <div class="vf"><label class="lz">Z</label><input class="ni" id="sz" type="number" step="0.1" onchange="applyTf()"></div>
                        </div>
                    </div>
                </div>

                <!-- Material -->
                <div class="prop-sec">
                    <div class="sec-head" onclick="toggleSec(this)">–ú–∞—Ç–µ—Ä–∏–∞–ª <i class="chev">‚ñæ</i></div>
                    <div class="sec-body">
                        <div class="cr">
                            <input type="color" class="ci" id="mc" value="#00d4ff" onchange="applyMat()">
                            <span class="cl">–¶–≤–µ—Ç –æ–±—ä–µ–∫—Ç–∞</span>
                        </div>
                        <div class="rr"><label>–ú–µ—Ç–∞–ª–ª–∏–∫</label><input type="range" class="ri" id="mm" min="0" max="1" step="0.01" value="0" oninput="rng(this,'mmv');applyMat()"><span class="rv" id="mmv">0</span></div>
                        <div class="rr"><label>–®–µ—Ä–æ—Ö–æ–≤.</label><input type="range" class="ri" id="mr" min="0" max="1" step="0.01" value="0.5" oninput="rng(this,'mrv');applyMat()"><span class="rv" id="mrv">0.5</span></div>
                        <div class="rr"><label>–ü—Ä–æ–∑—Ä–∞—á–Ω.</label><input type="range" class="ri" id="mo" min="0" max="1" step="0.01" value="1" oninput="rng(this,'mov');applyMat()"><span class="rv" id="mov">1</span></div>
                        <div class="tr"><label>–ö–∞—Ä–∫–∞—Å</label><div class="tog" id="tog-wire" onclick="toggleWireObj()"></div></div>
                    </div>
                </div>

                <!-- Boolean -->
                <div class="prop-sec">
                    <div class="sec-head" onclick="toggleSec(this)">–ë—É–ª–µ–≤—ã –æ–ø–µ—Ä–∞—Ü–∏–∏ <i class="chev">‚ñæ</i></div>
                    <div class="sec-body">
                        <div class="bool-hint" id="bool-hint">–í—ã–±–µ—Ä–∏—Ç–µ 2 –æ–±—ä–µ–∫—Ç–∞ (Shift+–∫–ª–∏–∫), –∑–∞—Ç–µ–º –≤—ã–±–µ—Ä–∏—Ç–µ –æ–ø–µ—Ä–∞—Ü–∏—é:</div>
                        <div class="bool-grid">
                            <button class="bool-btn" onclick="boolOp('union')"><span class="bi">‚äï</span>–û–±—ä–µ–¥.</button>
                            <button class="bool-btn" onclick="boolOp('subtract')"><span class="bi">‚äñ</span>–í—ã—á–∏—Ç.</button>
                            <button class="bool-btn" onclick="boolOp('intersect')"><span class="bi">‚äó</span>–ü–µ—Ä–µ—Å–µ—á.</button>
                        </div>
                    </div>
                </div>

                <!-- Geom params -->
                <div class="prop-sec">
                    <div class="sec-head" onclick="toggleSec(this)">–ì–µ–æ–º–µ—Ç—Ä–∏—è <i class="chev">‚ñæ</i></div>
                    <div class="sec-body" id="geom-body"></div>
                </div>

            </div>
        </div>

        <!-- ‚ïê‚ïê‚ïê STATUSBAR ‚ïê‚ïê‚ïê -->
        <div id="statusbar">
            <div class="si">Ren3D <span>v2.0</span></div>
            <div class="ss">|</div>
            <div class="si">–í—ã–±—Ä–∞–Ω–æ: <span id="sel-cnt">0</span></div>
            <div class="spacer"></div>
            <div style="display:flex;gap:6px;align-items:center">
                <span class="kbd">–ü–ö–ú</span>–û—Ä–±–∏—Ç–∞
                <span class="kbd">–°–ö–ú</span>–ü–∞–Ω
                <span class="kbd">–ö–æ–ª–µ—Å–æ</span>–ó—É–º
                <span class="kbd">F</span>–§–æ–∫—É—Å
                <span class="kbd">Del</span>–£–¥–∞–ª–∏—Ç—å
                <span class="kbd">Ctrl+D</span>–î—É–±–ª–∏—Ä–æ–≤–∞—Ç—å
                <span class="kbd">Ctrl+J</span>–û–±—ä–µ–¥–∏–Ω–∏—Ç—å
                <span class="kbd">Z</span>–ö–∞—Ä–∫–∞—Å
            </div>
        </div>
    </div>

    <input type="file" id="file-in" accept=".stl,.obj" onchange="handleFile(event)">
    <input type="file" id="proj-in" accept=".r3d" onchange="handleProjectOpen(event)">
    <div id="toast" style="opacity:0"></div>

    <!-- THREE.JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  REN3D v2 ‚Äî Core Engine
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        'use strict';

        // ‚îÄ‚îÄ State ‚îÄ‚îÄ
        let scene, camera, renderer, raycaster;
        const orbit = { theta: 0.7, phi: 1.1, radius: 10, target: new THREE.Vector3() };
        let mb = -1, drag = false, lm = { x: 0, y: 0 }, mouse = new THREE.Vector2();

        let objs = [];
        let sel = [];
        let counter = {};
        let gridOn = true, wireOn = false;
        let activeTool = 'sel';
        let gizmoMode = 'none';
        let gridMesh;

        let gizmo = null;
        let gizmoActive = false, gizmoAxis = null;

        let undoStack = [], redoStack = [];

        const PALETTE = ['#00d4ff', '#ff6b35', '#39ff8f', '#b78bff', '#ffe066', '#ff4466', '#4499ff', '#ffaa44'];
        let ci = 0;

        // ‚îÄ‚îÄ Init ‚îÄ‚îÄ
        function init() {
            const canvas = document.getElementById('c3d');
            const vp = document.getElementById('vp');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050508);

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            resize();

            camera = new THREE.PerspectiveCamera(55, 1, 0.01, 1000);
            updateCam();

            raycaster = new THREE.Raycaster();

            scene.add(new THREE.AmbientLight(0xffffff, 0.35));
            const key = new THREE.DirectionalLight(0xffffff, 0.9);
            key.position.set(6, 10, 6); key.castShadow = true;
            key.shadow.mapSize.set(2048, 2048);
            scene.add(key);
            const fill = new THREE.DirectionalLight(0x4488ff, 0.25);
            fill.position.set(-6, 2, -4); scene.add(fill);
            const rim = new THREE.DirectionalLight(0x00d4ff, 0.15);
            rim.position.set(0, -4, 6); scene.add(rim);

            buildGrid();

            canvas.addEventListener('mousedown', onMD);
            canvas.addEventListener('mousemove', onMM);
            canvas.addEventListener('mouseup', onMU);
            canvas.addEventListener('wheel', onWheel, { passive: false });
            canvas.addEventListener('contextmenu', onCtx);
            // FIX: capture=true –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç –ø–æ–ª—É—á–µ–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π –Ω–∞ Linux –¥–∞–∂–µ –∫–æ–≥–¥–∞ —Ñ–æ–∫—É—Å –Ω–∞ canvas
            window.addEventListener('keydown', onKey, true);
            window.addEventListener('resize', resize);
            document.addEventListener('click', closeMenus);

            // FIX LINUX CTRL+KEY via IPC
            if (window.electronAPI && window.electronAPI.onCtrlKey) {
                window.electronAPI.onCtrlKey(({ key, shift }) => {
                    switch (key) {
                        case 'z': undo(); break;
                        case 'y': redo(); break;
                        case 'd': duplicateSel(); break;
                        case 'a': selectAll(); break;
                        case 'i': doImport(); break;
                        case 'e': showExportModal(); break;
                        case 'n': newScene(); break;
                        case 's': saveProject(); break;
                        case 'o': openProject(); break;
                        case 'j': shift ? boolOp('subtract') : boolOp('union'); break;
                    }
                });
            }

            initResizablePanels();

            animate();
            updateStats();
        }

        function buildGrid() {
            if (gridMesh) scene.remove(gridMesh);
            gridMesh = new THREE.GridHelper(24, 24, 0x1a1a2e, 0x111120);
            scene.add(gridMesh);
        }

        function resize() {
            const vp = document.getElementById('vp');
            const w = vp.clientWidth, h = vp.clientHeight;
            renderer.setSize(w, h);
            if (camera) { camera.aspect = w / h; camera.updateProjectionMatrix(); }
        }

        function animate() {
            requestAnimationFrame(animate);
            updateGizmoMeshPosition();
            renderer.render(scene, camera);
            drawOriGizmo();
        }

        // ‚îÄ‚îÄ Camera ‚îÄ‚îÄ
        function updateCam() {
            const { theta, phi, radius, target } = orbit;
            camera.position.set(
                target.x + radius * Math.sin(phi) * Math.sin(theta),
                target.y + radius * Math.cos(phi),
                target.z + radius * Math.sin(phi) * Math.cos(theta)
            );
            camera.lookAt(target);
        }

        function camView(v) {
            if (v === 'persp') { orbit.theta = 0.7; orbit.phi = 1.1; }
            else if (v === 'front') { orbit.theta = 0; orbit.phi = Math.PI / 2; }
            else if (v === 'top') { orbit.theta = 0; orbit.phi = 0.02; }
            else if (v === 'right') { orbit.theta = Math.PI / 2; orbit.phi = Math.PI / 2; }
            updateCam(); closeAllMenus();
        }

        // ‚îÄ‚îÄ Mouse ‚îÄ‚îÄ
        function onMD(e) {
            e.preventDefault();
            drag = false; mb = e.button; lm = { x: e.clientX, y: e.clientY };
            updateMouse(e);

            if (mb === 0 && gizmoMode !== 'none' && sel.length > 0) {
                const hit = hitTestGizmo();
                if (hit) {
                    gizmoActive = true;
                    gizmoAxis = hit;
                    return;
                }
            }
        }

        function onMM(e) {
            const dx = e.clientX - lm.x, dy = e.clientY - lm.y;
            if (Math.abs(dx) > 1.5 || Math.abs(dy) > 1.5) drag = true;
            updateMouse(e);

            if (gizmoActive && mb === 0) {
                applyGizmoTransform(e, dx, dy);
                lm = { x: e.clientX, y: e.clientY };
                return;
            }

            if (mb === 2 || mb === 1) {
                orbit.theta -= dx * 0.005;
                orbit.phi = Math.max(0.04, Math.min(Math.PI - 0.04, orbit.phi - dy * 0.005));
                updateCam();
            }
            lm = { x: e.clientX, y: e.clientY };
        }

        function onMU(e) {
            if (gizmoActive) {
                gizmoActive = false;
                if (sel.length > 0) saveUndo();
                updatePropsPanel();
                mb = -1; return;
            }
            if (!drag && mb === 0) handleClick(e);
            mb = -1; drag = false;
        }

        function onWheel(e) {
            e.preventDefault();
            orbit.radius = Math.max(0.3, Math.min(200, orbit.radius * (1 + e.deltaY * 0.001)));
            updateCam();
        }

        function updateMouse(e) {
            const vp = document.getElementById('vp');
            const r = vp.getBoundingClientRect();
            mouse.set(((e.clientX - r.left) / r.width) * 2 - 1, -((e.clientY - r.top) / r.height) * 2 + 1);
        }

        document.getElementById('c3d').addEventListener('mousedown', e => { if (e.button === 2) mb = 2; });
        document.addEventListener('mousemove', e => {
            if (mb === 2 && drag) {
                const dx = e.clientX - lm.x, dy = e.clientY - lm.y;
                const right = new THREE.Vector3().crossVectors(camera.getWorldDirection(new THREE.Vector3()), camera.up).normalize();
                const up = new THREE.Vector3(0, 1, 0);
                const sp = orbit.radius * 0.003;
                orbit.target.addScaledVector(right, -dx * sp);
                orbit.target.addScaledVector(up, dy * sp);
                updateCam(); lm = { x: e.clientX, y: e.clientY };
            }
        });

        // ‚îÄ‚îÄ Click / Selection ‚îÄ‚îÄ
        function handleClick(e) {
            raycaster.setFromCamera(mouse, camera);
            const meshes = objs.map(o => o.mesh);
            const hits = raycaster.intersectObjects(meshes);

            if (hits.length) {
                const obj = objs.find(o => o.mesh === hits[0].object);
                if (obj) {
                    if (e.shiftKey) toggleSel(obj);
                    else selectObj(obj, true);
                }
            } else {
                if (!e.shiftKey) deselectAll();
            }
        }

        function selectObj(obj, excl = false) {
            if (excl) deselectAll(false);
            if (!sel.includes(obj)) {
                sel.push(obj);
                obj.mesh.material.emissive = new THREE.Color(0x00d4ff);
                obj.mesh.material.emissiveIntensity = 0.12;
            }
            updateSelUI(); showGizmoMesh();
        }

        function toggleSel(obj) {
            const i = sel.indexOf(obj);
            if (i >= 0) { sel.splice(i, 1); obj.mesh.material.emissive = new THREE.Color(0); obj.mesh.material.emissiveIntensity = 0; }
            else { sel.push(obj); obj.mesh.material.emissive = new THREE.Color(0x00d4ff); obj.mesh.material.emissiveIntensity = 0.12; }
            updateSelUI(); showGizmoMesh();
        }

        function deselectAll(upd = true) {
            sel.forEach(o => { if (o && o.mesh && o.mesh.material) { o.mesh.material.emissive = new THREE.Color(0); o.mesh.material.emissiveIntensity = 0; } });
            sel = [];
            hideGizmoMesh();
            if (upd) updateSelUI();
        }

        function selectAll() {
            deselectAll(false);
            objs.forEach(o => { sel.push(o); o.mesh.material.emissive = new THREE.Color(0x00d4ff); o.mesh.material.emissiveIntensity = 0.12; });
            updateSelUI(); showGizmoMesh();
        }

        function updateSelUI() {
            document.querySelectorAll('.tree-node').forEach(el => {
                const id = +el.dataset.id;
                el.classList.toggle('sel', sel.some(o => o.id === id));
            });
            document.getElementById('sel-cnt').textContent = sel.length;

            const noSel = document.getElementById('no-sel');
            const props = document.getElementById('props');

            if (sel.length === 1) {
                // –û–¥–∏–Ω –æ–±—ä–µ–∫—Ç: –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ —Å–µ–∫—Ü–∏–∏ –∏ –∑–∞–ø–æ–ª–Ω—è–µ–º –ø—Ä–æ–ø—Å—ã
                noSel.style.display = 'none';
                props.style.display = 'block';
                props.querySelectorAll('.prop-sec').forEach(sec => sec.style.display = 'block');
                // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π —Ç–µ–∫—Å—Ç –ø–æ–¥—Å–∫–∞–∑–∫–∏ Boolean
                const hint = document.getElementById('bool-hint');
                if (hint) hint.innerHTML = '–í—ã–±–µ—Ä–∏—Ç–µ 2 –æ–±—ä–µ–∫—Ç–∞ (Shift+–∫–ª–∏–∫), –∑–∞—Ç–µ–º –≤—ã–±–µ—Ä–∏—Ç–µ –æ–ø–µ—Ä–∞—Ü–∏—é:';
                updatePropsPanel();
            } else if (sel.length === 0) {
                // –ù–∏—á–µ–≥–æ –Ω–µ –≤—ã–±—Ä–∞–Ω–æ
                noSel.style.display = 'flex';
                props.style.display = 'none';
                noSel.innerHTML = '<div class="nosel-ico">‚óà</div><span style="color:var(--ink-dim)">–ù–∏—á–µ–≥–æ –Ω–µ –≤—ã–±—Ä–∞–Ω–æ</span><span style="color:var(--ink-ghost);font-size:10px">–ö–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ –æ–±—ä–µ–∫—Ç</span>';
            } else {
                // FIX: 2+ –æ–±—ä–µ–∫—Ç–∞ ‚Äî –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ —Å–µ–∫—Ü–∏—é Boolean –æ–ø–µ—Ä–∞—Ü–∏–π
                noSel.style.display = 'none';
                props.style.display = 'block';
                props.querySelectorAll('.prop-sec').forEach((sec, i) => {
                    // Boolean-—Å–µ–∫—Ü–∏—è ‚Äî —Ç—Ä–µ—Ç—å—è (index 2), –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø—Ä—è—á–µ–º
                    sec.style.display = (i === 2) ? 'block' : 'none';
                });
                // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–¥—Å–∫–∞–∑–∫—É —Å —Ö–æ—Ç–∫–µ—è–º–∏
                const hint = document.getElementById('bool-hint');
                if (hint) hint.innerHTML = `–í—ã–±—Ä–∞–Ω–æ: <b style="color:var(--cyan)">${sel.length}</b> –æ–±—ä–µ–∫—Ç–∞. –ü—Ä–∏–º–µ–Ω–∏—Ç—å –æ–ø–µ—Ä–∞—Ü–∏—é:<br><span style="color:var(--ink-dim)">Ctrl+J ‚Äî –û–±—ä–µ–¥–∏–Ω–∏—Ç—å &nbsp;|&nbsp; Ctrl+Shift+J ‚Äî –í—ã—á–µ—Å—Ç—å</span>`;
            }
        }

        // ‚îÄ‚îÄ Props Panel ‚îÄ‚îÄ
        function updatePropsPanel() {
            if (sel.length !== 1) return;
            const obj = sel[0], m = obj.mesh;
            const deg = THREE.MathUtils.radToDeg;
            // Object name
            const nameInp = document.getElementById('obj-name-input');
            if (nameInp) nameInp.value = obj.name;

            const set = (id, v) => { const el = document.getElementById(id); if (el) el.value = typeof v === 'number' ? +v.toFixed(4) : v; };
            set('px', m.position.x); set('py', m.position.y); set('pz', m.position.z);
            set('rx', deg(m.rotation.x)); set('ry', deg(m.rotation.y)); set('rz', deg(m.rotation.z));
            set('sx', m.scale.x); set('sy', m.scale.y); set('sz', m.scale.z);
            set('mc', '#' + m.material.color.getHexString());
            set('mm', m.material.metalness || 0);
            set('mr', m.material.roughness !== undefined ? m.material.roughness : 0.5);
            set('mo', m.material.opacity !== undefined ? m.material.opacity : 1);
            document.getElementById('mmv').textContent = (+document.getElementById('mm').value).toFixed(2);
            document.getElementById('mrv').textContent = (+document.getElementById('mr').value).toFixed(2);
            document.getElementById('mov').textContent = (+document.getElementById('mo').value).toFixed(2);
            document.getElementById('tog-wire').classList.toggle('on', m.material.wireframe || false);
            buildGeomProps(obj);
        }

        function buildGeomProps(obj) {
            const el = document.getElementById('geom-body');
            const p = obj.params || {};
            let h = '';
            if (obj.type === 'box') {
                h = `<div class="plabel">–†–∞–∑–º–µ—Ä</div><div class="v3">
              <div class="vf"><label>–®</label><input class="ni" id="gw" type="number" step="0.1" value="${p.w || 1}" onchange="rebuildGeom()"></div>
              <div class="vf"><label>–í</label><input class="ni" id="gh" type="number" step="0.1" value="${p.h || 1}" onchange="rebuildGeom()"></div>
              <div class="vf"><label>–ì</label><input class="ni" id="gd" type="number" step="0.1" value="${p.d || 1}" onchange="rebuildGeom()"></div></div>`;
            } else if (obj.type === 'sphere') {
                h = `<div class="plabel">–ü–∞—Ä–∞–º–µ—Ç—Ä—ã</div><div class="v3">
              <div class="vf"><label>–†–∞–¥–∏—É—Å</label><input class="ni" id="gr" type="number" step="0.1" value="${p.r || 0.5}" onchange="rebuildGeom()"></div>
              <div class="vf"><label>–°–µ–≥.W</label><input class="ni" id="gsw" type="number" step="1" value="${p.sw || 32}" onchange="rebuildGeom()"></div>
              <div class="vf"><label>–°–µ–≥.H</label><input class="ni" id="gsh" type="number" step="1" value="${p.sh || 16}" onchange="rebuildGeom()"></div></div>`;
            } else if (obj.type === 'cyl') {
                h = `<div class="plabel">–ü–∞—Ä–∞–º–µ—Ç—Ä—ã</div><div class="v3">
              <div class="vf"><label>R –≤–µ—Ä—Ö</label><input class="ni" id="grt" type="number" step="0.1" value="${p.rt || 0.5}" onchange="rebuildGeom()"></div>
              <div class="vf"><label>R –Ω–∏–∑</label><input class="ni" id="grb" type="number" step="0.1" value="${p.rb || 0.5}" onchange="rebuildGeom()"></div>
              <div class="vf"><label>–í—ã—Å–æ—Ç–∞</label><input class="ni" id="gch" type="number" step="0.1" value="${p.h || 1}" onchange="rebuildGeom()"></div></div>`;
            } else if (obj.type === 'cone') {
                h = `<div class="plabel">–ü–∞—Ä–∞–º–µ—Ç—Ä—ã</div><div class="v3">
              <div class="vf"><label>–†–∞–¥–∏—É—Å</label><input class="ni" id="gcor" type="number" step="0.1" value="${p.r || 0.5}" onchange="rebuildGeom()"></div>
              <div class="vf"><label>–í—ã—Å–æ—Ç–∞</label><input class="ni" id="gcoh" type="number" step="0.1" value="${p.h || 1}" onchange="rebuildGeom()"></div>
              <div class="vf"><label>–°–µ–≥–º.</label><input class="ni" id="gcos" type="number" step="1" value="${p.s || 32}" onchange="rebuildGeom()"></div></div>`;
            } else if (obj.type === 'torus') {
                h = `<div class="plabel">–ü–∞—Ä–∞–º–µ—Ç—Ä—ã</div><div class="v3">
              <div class="vf"><label>R</label><input class="ni" id="gtr" type="number" step="0.1" value="${p.r || 0.5}" onchange="rebuildGeom()"></div>
              <div class="vf"><label>–¢—Ä—É–±–∫–∞</label><input class="ni" id="gtt" type="number" step="0.05" value="${p.t || 0.2}" onchange="rebuildGeom()"></div>
              <div class="vf"><label>–°–µ–≥–º.</label><input class="ni" id="gts" type="number" step="1" value="${p.s || 32}" onchange="rebuildGeom()"></div></div>`;
            }
            el.innerHTML = h;
        }

        function rebuildGeom() {
            if (sel.length !== 1) return;
            const obj = sel[0];
            saveUndo();
            const g = id => { const e = document.getElementById(id); return e ? parseFloat(e.value) : 0; };
            const gi = id => { const e = document.getElementById(id); return e ? parseInt(e.value) : 1; };
            let geom, params;
            if (obj.type === 'box') {
                params = { w: g('gw') || 1, h: g('gh') || 1, d: g('gd') || 1 };
                geom = new THREE.BoxGeometry(params.w, params.h, params.d);
            } else if (obj.type === 'sphere') {
                params = { r: g('gr') || 0.5, sw: gi('gsw') || 32, sh: gi('gsh') || 16 };
                geom = new THREE.SphereGeometry(params.r, params.sw, params.sh);
            } else if (obj.type === 'cyl') {
                params = { rt: g('grt') || 0.5, rb: g('grb') || 0.5, h: g('gch') || 1 };
                geom = new THREE.CylinderGeometry(params.rt, params.rb, params.h, 32);
            } else if (obj.type === 'cone') {
                params = { r: g('gcor') || 0.5, h: g('gcoh') || 1, s: gi('gcos') || 32 };
                geom = new THREE.ConeGeometry(params.r, params.h, params.s);
            } else if (obj.type === 'torus') {
                params = { r: g('gtr') || 0.5, t: g('gtt') || 0.2, s: gi('gts') || 32 };
                geom = new THREE.TorusGeometry(params.r, params.t, 16, params.s);
            }
            if (geom) { obj.mesh.geometry.dispose(); obj.mesh.geometry = geom; obj.params = params; updateStats(); }
        }

        // ‚îÄ‚îÄ Add Objects ‚îÄ‚îÄ
        function addObj(type) {
            saveUndo();
            const color = PALETTE[ci % PALETTE.length]; ci++;
            const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color(color), roughness: 0.45, metalness: 0 });
            let geom, params;
            const names = { box: '–ö—É–±', sphere: '–°—Ñ–µ—Ä–∞', cyl: '–¶–∏–ª–∏–Ω–¥—Ä', cone: '–ö–æ–Ω—É—Å', torus: '–¢–æ—Ä', plane: '–ü–ª–æ—Å–∫–æ—Å—Ç—å' };

            if (type === 'box') { geom = new THREE.BoxGeometry(1, 1, 1); params = { w: 1, h: 1, d: 1 }; }
            else if (type === 'sphere') { geom = new THREE.SphereGeometry(0.5, 32, 16); params = { r: 0.5, sw: 32, sh: 16 }; }
            else if (type === 'cyl') { geom = new THREE.CylinderGeometry(0.5, 0.5, 1, 32); params = { rt: 0.5, rb: 0.5, h: 1 }; }
            else if (type === 'cone') { geom = new THREE.ConeGeometry(0.5, 1, 32); params = { r: 0.5, h: 1, s: 32 }; }
            else if (type === 'torus') { geom = new THREE.TorusGeometry(0.5, 0.2, 16, 32); params = { r: 0.5, t: 0.2, s: 32 }; }
            else if (type === 'plane') { geom = new THREE.PlaneGeometry(1, 1); params = { w: 1, h: 1 }; }

            const mesh = new THREE.Mesh(geom, mat);
            mesh.castShadow = true; mesh.receiveShadow = true;
            mesh.position.set((Math.random() - .5) * .4, 0.5, (Math.random() - .5) * .4);
            scene.add(mesh);

            if (!counter[type]) counter[type] = 0; counter[type]++;
            const obj = { id: Date.now() + Math.random(), type, name: `${names[type]} ${counter[type]}`, mesh, params };
            objs.push(obj);
            updateTree(); updateStats();
            deselectAll(false); selectObj(obj, true);
            document.getElementById('empty-hint').style.display = 'none';
            closeAllMenus();
        }

        // ‚îÄ‚îÄ Scene Tree ‚îÄ‚îÄ
        function updateTree() {
            const tree = document.getElementById('tree-wrap');
            const icons = { box: '‚¨õ', sphere: 'üîµ', cyl: 'üî∑', cone: 'üî∫', torus: '‚≠ï', plane: '‚¨ú', imported: 'üì¶', merged: 'üî≤' };
            tree.innerHTML = objs.map(o => `
            <div class="tree-node ${sel.includes(o) ? 'sel' : ''} ${o.mesh && !o.mesh.visible ? 'hidden-obj' : ''}"
                 data-id="${o.id}" onclick="treeClick(event,${o.id})" ondblclick="treeDbClick(${o.id})">
              <span class="tn-ico">${icons[o.type] || 'üì¶'}</span>
              <span class="tn-name">${o.name}</span>
              <span class="tn-eye" onclick="toggleVis(event,${o.id})">üëÅ</span>
            </div>`).join('');
            document.getElementById('obj-cnt').textContent = objs.length;
        }

        function treeClick(e, id) {
            const o = objs.find(x => x.id === id); if (!o) return;
            if (e.shiftKey) toggleSel(o); else selectObj(o, true);
        }
        function treeDbClick(id) {
            const o = objs.find(x => x.id === id); if (!o) return;
            // Double-click: inline rename
            const node = document.querySelector(`.tree-node[data-id="${id}"]`);
            if (!node) return;
            const nameSpan = node.querySelector('.tn-name');
            const inp = document.createElement('input');
            inp.className = 'tn-rename';
            inp.value = o.name;
            nameSpan.replaceWith(inp);
            inp.focus(); inp.select();
            const commit = () => {
                const v = inp.value.trim();
                if (v) o.name = v;
                updateTree();
                // re-select to refresh inspector
                if (sel.includes(o)) { const ni = document.getElementById('obj-name-input'); if (ni) ni.value = o.name; }
            };
            inp.addEventListener('blur', commit);
            inp.addEventListener('keydown', ev => {
                if (ev.key === 'Enter') inp.blur();
                if (ev.key === 'Escape') { inp.value = o.name; inp.blur(); }
                ev.stopPropagation();
            });
        }
        function toggleVis(e, id) {
            e.stopPropagation();
            const o = objs.find(x => x.id === id); if (!o) return;
            o.mesh.visible = !o.mesh.visible; updateTree();
        }

        // ‚îÄ‚îÄ Transform Panel ‚îÄ‚îÄ
        function applyTf() {
            if (sel.length !== 1) return;
            const m = sel[0].mesh, r = THREE.MathUtils.degToRad;
            const g = id => parseFloat(document.getElementById(id).value) || 0;
            m.position.set(g('px'), g('py'), g('pz'));
            m.rotation.set(r(g('rx')), r(g('ry')), r(g('rz')));
            m.scale.set(g('sx') || 1, g('sy') || 1, g('sz') || 1);
            saveUndo();
            showGizmoMesh();
        }

        function applyObjName() {
            if (sel.length !== 1) return;
            const inp = document.getElementById('obj-name-input');
            if (!inp) return;
            const newName = inp.value.trim();
            if (newName && newName !== sel[0].name) {
                sel[0].name = newName;
                updateTree();
            }
        }

        function applyMat() {
            if (sel.length !== 1) return;
            const mat = sel[0].mesh.material;
            mat.color.set(document.getElementById('mc').value);
            mat.metalness = +document.getElementById('mm').value;
            mat.roughness = +document.getElementById('mr').value;
            mat.opacity = +document.getElementById('mo').value;
            mat.transparent = mat.opacity < 1;
            mat.needsUpdate = true;
        }

        function toggleWireObj() {
            if (sel.length !== 1) return;
            const mat = sel[0].mesh.material;
            mat.wireframe = !mat.wireframe;
            document.getElementById('tog-wire').classList.toggle('on', mat.wireframe);
        }

        function rng(el, vid) { document.getElementById(vid).textContent = parseFloat(el.value).toFixed(2); }

        // ‚îÄ‚îÄ Delete / Duplicate ‚îÄ‚îÄ
        function deleteSel() {
            if (!sel.length) return;
            saveUndo();
            sel.forEach(o => { scene.remove(o.mesh); o.mesh.geometry.dispose(); o.mesh.material.dispose(); objs.splice(objs.indexOf(o), 1); });
            sel = [];
            hideGizmoMesh();
            updateTree(); updateStats(); updateSelUI();
            if (!objs.length) document.getElementById('empty-hint').style.display = 'block';
        }

        function duplicateSel() {
            if (!sel.length) return;
            saveUndo();
            const newObjs = [];
            sel.forEach(o => {
                const ng = o.mesh.geometry.clone(), nm = o.mesh.material.clone();
                const mesh = new THREE.Mesh(ng, nm);
                mesh.castShadow = true; mesh.receiveShadow = true;
                mesh.position.copy(o.mesh.position).add(new THREE.Vector3(.5, 0, .5));
                mesh.rotation.copy(o.mesh.rotation); mesh.scale.copy(o.mesh.scale);
                scene.add(mesh);
                const no = { id: Date.now() + Math.random(), type: o.type, name: o.name + ' (–∫–æ–ø–∏—è)', mesh, params: { ...o.params } };
                objs.push(no); newObjs.push(no);
            });
            deselectAll(false);
            newObjs.forEach(o => { sel.push(o); o.mesh.material.emissive = new THREE.Color(0x00d4ff); o.mesh.material.emissiveIntensity = 0.12; });
            updateTree(); updateStats(); updateSelUI(); showGizmoMesh();
        }

        // ‚îÄ‚îÄ Framing ‚îÄ‚îÄ
        function frameSel() { if (sel.length) frameObjs(sel.map(o => o.mesh)); else frameAll(); }
        function frameAll() { if (objs.length) frameObjs(objs.map(o => o.mesh)); }
        function frameObjs(meshes) {
            const box = new THREE.Box3();
            meshes.forEach(m => box.expandByObject(m));
            const size = box.getSize(new THREE.Vector3());
            orbit.target.copy(box.getCenter(new THREE.Vector3()));
            orbit.radius = Math.max(size.length() * 1.8, 1.5);
            updateCam();
        }

        // ‚îÄ‚îÄ Stats ‚îÄ‚îÄ
        function updateStats() {
            let tris = 0;
            objs.forEach(o => { const g = o.mesh.geometry; tris += g.index ? g.index.count / 3 : g.attributes.position.count / 3; });
            document.getElementById('vp-stats').textContent = `–û–±—ä–µ–∫—Ç–æ–≤: ${objs.length} | –¢—Ä–∏—Å: ${Math.round(tris).toLocaleString('ru')}`;
        }

        // ‚îÄ‚îÄ Grid / Wireframe ‚îÄ‚îÄ
        function toggleGrid() { gridOn = !gridOn; gridMesh.visible = gridOn; closeAllMenus(); }
        function toggleWire() {
            wireOn = !wireOn;
            objs.forEach(o => { o.mesh.material.wireframe = wireOn; });
            closeAllMenus();
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  VISUAL TRANSFORM GIZMO
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        let gizmoMeshes = {};
        let gizmoRoot = null;
        let gizmoHovAxis = null;

        function _mat(color, opacity) {
            opacity = (opacity === undefined) ? 1.0 : opacity;
            return new THREE.MeshBasicMaterial({
                color: color,
                depthTest: false,
                depthWrite: false,
                transparent: (opacity < 1.0),
                opacity: opacity,
            });
        }
        function _hitMat() {
            return new THREE.MeshBasicMaterial({
                transparent: true,
                opacity: 0,
                depthTest: false,
                depthWrite: false,
                side: THREE.DoubleSide,
            });
        }

        function _buildArrow(parent, axisKey, color, worldDir, tipStyle) {
            const g = new THREE.Group();

            const shaft = new THREE.Mesh(
                new THREE.CylinderGeometry(0.030, 0.030, 0.75, 12),
                _mat(color, 0.92)
            );
            shaft.position.y = 0.375;
            g.add(shaft);

            if (tipStyle === 'cone') {
                const cone = new THREE.Mesh(
                    new THREE.ConeGeometry(0.080, 0.22, 12),
                    _mat(color, 1.0)
                );
                cone.position.y = 0.86;
                g.add(cone);
            } else {
                const box = new THREE.Mesh(
                    new THREE.BoxGeometry(0.15, 0.15, 0.15),
                    _mat(color, 1.0)
                );
                box.position.y = 0.83;
                g.add(box);
            }

            const hit = new THREE.Mesh(
                new THREE.CylinderGeometry(0.14, 0.14, 1.10, 10),
                _hitMat()
            );
            hit.position.y = 0.55;
            hit.userData.axis = axisKey;
            hit.userData.isGizmo = true;
            g.add(hit);

            const up = new THREE.Vector3(0, 1, 0);
            const dir = worldDir.clone().normalize();
            if (Math.abs(up.dot(dir)) > 0.9999) {
                if (dir.y < 0) g.rotation.z = Math.PI;
            } else {
                g.quaternion.setFromUnitVectors(up, dir);
            }

            parent.add(g);
            return hit;
        }

        function _buildRing(parent, axisKey, color, rx, ry, rz) {
            const RADIUS = 0.90;
            const TUBE = 0.036;
            const HIT_TUBE = 0.13;
            const SEG = 64;

            const ring = new THREE.Mesh(
                new THREE.TorusGeometry(RADIUS, TUBE, 10, SEG),
                _mat(color, 0.90)
            );
            ring.rotation.set(rx, ry, rz);
            ring.userData.axis = axisKey;
            ring.userData.isGizmo = true;
            ring.renderOrder = 1001;

            const hitRing = new THREE.Mesh(
                new THREE.TorusGeometry(RADIUS, HIT_TUBE, 8, SEG),
                _hitMat()
            );
            hitRing.rotation.set(rx, ry, rz);
            hitRing.userData.axis = axisKey;
            hitRing.userData.isGizmo = true;

            parent.add(ring);
            parent.add(hitRing);
            return hitRing;
        }

        function buildGizmoMeshes() {
            if (gizmoRoot) { scene.remove(gizmoRoot); gizmoRoot = null; }
            gizmoMeshes = {};
            if (gizmoMode === 'none' || !sel.length) return;

            gizmoRoot = new THREE.Group();
            gizmoRoot.renderOrder = 999;

            if (gizmoMode === 'translate') {
                gizmoMeshes['x'] = _buildArrow(gizmoRoot, 'x', 0xff3355, new THREE.Vector3(1, 0, 0), 'cone');
                gizmoMeshes['y'] = _buildArrow(gizmoRoot, 'y', 0x33ff77, new THREE.Vector3(0, 1, 0), 'cone');
                gizmoMeshes['z'] = _buildArrow(gizmoRoot, 'z', 0x3399ff, new THREE.Vector3(0, 0, 1), 'cone');
            } else if (gizmoMode === 'rotate') {
                gizmoMeshes['x'] = _buildRing(gizmoRoot, 'x', 0xff3355, 0, Math.PI / 2, 0);
                gizmoMeshes['y'] = _buildRing(gizmoRoot, 'y', 0x33ff77, -Math.PI / 2, 0, 0);
                gizmoMeshes['z'] = _buildRing(gizmoRoot, 'z', 0x3399ff, 0, 0, 0);
            } else if (gizmoMode === 'scale') {
                gizmoMeshes['x'] = _buildArrow(gizmoRoot, 'x', 0xff3355, new THREE.Vector3(1, 0, 0), 'box');
                gizmoMeshes['y'] = _buildArrow(gizmoRoot, 'y', 0x33ff77, new THREE.Vector3(0, 1, 0), 'box');
                gizmoMeshes['z'] = _buildArrow(gizmoRoot, 'z', 0x3399ff, new THREE.Vector3(0, 0, 1), 'box');

                const uCube = new THREE.Mesh(
                    new THREE.BoxGeometry(0.20, 0.20, 0.20),
                    _mat(0xffffff, 0.95)
                );
                uCube.userData.axis = 'xyz';
                uCube.userData.isGizmo = true;
                gizmoRoot.add(uCube);
                gizmoMeshes['xyz'] = uCube;
            }

            gizmoRoot.position.copy(sel[0].mesh.position);
            _scaleGizmoToCamera();
            scene.add(gizmoRoot);
            gizmoRoot.updateMatrixWorld(true);
        }

        function _scaleGizmoToCamera() {
            if (!gizmoRoot) return;
            const dist = camera.position.distanceTo(gizmoRoot.position);
            gizmoRoot.scale.setScalar(Math.max(0.01, dist * 0.10));
        }

        function updateGizmoMeshPosition() {
            if (!gizmoRoot) return;
            if (gizmoMode === 'none' || !sel.length) { gizmoRoot.visible = false; return; }
            gizmoRoot.visible = true;
            gizmoRoot.position.copy(sel[0].mesh.position);
            _scaleGizmoToCamera();
        }

        function showGizmoMesh() {
            if (gizmoMode !== 'none' && sel.length) buildGizmoMeshes();
        }

        function hideGizmoMesh() {
            if (gizmoRoot) { scene.remove(gizmoRoot); gizmoRoot = null; }
            gizmoMeshes = {};
        }

        function hitTestGizmo() {
            if (!gizmoRoot || !gizmoRoot.visible) return null;
            raycaster.setFromCamera(mouse, camera);
            const hitMeshes = Object.values(gizmoMeshes).filter(Boolean);
            const hits = raycaster.intersectObjects(hitMeshes, true);
            if (!hits.length) return null;

            let obj = hits[0].object;
            while (obj) {
                if (obj.userData && obj.userData.isGizmo) return obj.userData.axis;
                obj = obj.parent;
            }
            return null;
        }

        function _screenAxisDir(worldAxisVec) {
            gizmoRoot.updateMatrixWorld(true);

            const origin = new THREE.Vector3().copy(gizmoRoot.position);
            const tip = new THREE.Vector3().copy(gizmoRoot.position).addScaledVector(worldAxisVec, 1.0);

            const projectToNDC = (v) => {
                const c = v.clone().project(camera);
                return new THREE.Vector2(c.x, c.y);
            };

            const s0 = projectToNDC(origin);
            const s1 = projectToNDC(tip);
            const dir = new THREE.Vector2().subVectors(s1, s0);

            if (dir.lengthSq() < 1e-10) return new THREE.Vector2(1, 0);
            return dir.normalize();
        }

        function applyGizmoTransform(e, rawDx, rawDy) {
            if (!sel.length || !gizmoAxis) return;
            const obj = sel[0];
            const vp = document.getElementById('vp');
            const W = vp.clientWidth;
            const H = vp.clientHeight;

            const ndcDx = rawDx / (W * 0.5);
            const ndcDy = -rawDy / (H * 0.5);
            const mDelta = new THREE.Vector2(ndcDx, ndcDy);

            const tSpeed = orbit.radius * 1.6;
            const rSpeed = 4.0;
            const sSpeed = 3.5;

            const worldAxes = {
                x: new THREE.Vector3(1, 0, 0),
                y: new THREE.Vector3(0, 1, 0),
                z: new THREE.Vector3(0, 0, 1),
            };

            if (gizmoMode === 'translate') {
                const wAxis = worldAxes[gizmoAxis];
                const sDir = _screenAxisDir(wAxis);
                const dot = mDelta.dot(sDir);
                obj.mesh.position.addScaledVector(wAxis, dot * tSpeed);
            } else if (gizmoMode === 'rotate') {
                const wAxis = worldAxes[gizmoAxis];
                const sDir = _screenAxisDir(wAxis);
                const tangent = new THREE.Vector2(-sDir.y, sDir.x);
                const dot = mDelta.dot(tangent);

                if (gizmoAxis === 'x') obj.mesh.rotation.x -= dot * rSpeed;
                else if (gizmoAxis === 'y') obj.mesh.rotation.y -= dot * rSpeed;
                else if (gizmoAxis === 'z') obj.mesh.rotation.z -= dot * rSpeed;
            } else if (gizmoMode === 'scale') {
                if (gizmoAxis === 'xyz') {
                    const factor = 1.0 + (-rawDy / H) * sSpeed * 2.0;
                    obj.mesh.scale.multiplyScalar(Math.max(0.001, factor));
                } else {
                    const wAxis = worldAxes[gizmoAxis];
                    const sDir = _screenAxisDir(wAxis);
                    const dot = mDelta.dot(sDir);
                    const factor = 1.0 + dot * sSpeed;
                    if (gizmoAxis === 'x') obj.mesh.scale.x = Math.max(0.001, obj.mesh.scale.x * factor);
                    else if (gizmoAxis === 'y') obj.mesh.scale.y = Math.max(0.001, obj.mesh.scale.y * factor);
                    else if (gizmoAxis === 'z') obj.mesh.scale.z = Math.max(0.001, obj.mesh.scale.z * factor);
                }
            }

            updatePropsPanel();
            if (gizmoRoot) {
                gizmoRoot.position.copy(obj.mesh.position);
                gizmoRoot.updateMatrixWorld(true);
            }
        }

        // ‚îÄ‚îÄ Tool / Gizmo Mode ‚îÄ‚îÄ
        function setTool(t) {
            activeTool = t;
            document.querySelectorAll('.tb-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('tbb-' + t)?.classList.add('active');
            const map = { sel: 'none', move: 'translate', rot: 'rotate', scale: 'scale' };
            setGizmoMode(map[t] || 'none');
        }

        function setGizmoMode(m) {
            gizmoMode = m;
            document.querySelectorAll('.tm-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('tmb-' + m)?.classList.add('active');
            hideGizmoMesh();
            if (m !== 'none' && sel.length) buildGizmoMeshes();
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  BOOLEAN OPERATIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        function boolOp(type) {
            if (sel.length < 2) { toast('–í—ã–±–µ—Ä–∏—Ç–µ 2 –æ–±—ä–µ–∫—Ç–∞ (Shift+–∫–ª–∏–∫)'); return; }
            saveUndo();
            const A = sel[0], B = sel[1];

            if (type === 'union') {
                performUnion(A, B);
            } else if (type === 'subtract') {
                performSubtract(A, B);
            } else if (type === 'intersect') {
                performIntersect(A, B);
            }
        }

        function getWorldGeom(obj) {
            // Ensure we have a non-indexed geometry with correct vertex count
            let g = obj.mesh.geometry.clone();
            g.applyMatrix4(obj.mesh.matrixWorld);
            // Convert to non-indexed to preserve all triangles
            if (g.index) {
                g = g.toNonIndexed();
            }
            g.computeVertexNormals();
            return g;
        }

        function _addVertexColors(geom, color, vertCount) {
            const c = new THREE.Color(color);
            const cols = new Float32Array(vertCount * 3);
            for (let i = 0; i < vertCount; i++) {
                cols[i * 3] = c.r; cols[i * 3 + 1] = c.g; cols[i * 3 + 2] = c.b;
            }
            geom.setAttribute('color', new THREE.BufferAttribute(cols, 3));
        }

        function performUnion(A, B) {
            const gA = getWorldGeom(A);
            const gB = getWorldGeom(B);
            _addVertexColors(gA, A.mesh.material.color, gA.attributes.position.count);
            _addVertexColors(gB, B.mesh.material.color, gB.attributes.position.count);
            const merged = mergeGeomsWithColors(gA, gB);
            merged.computeVertexNormals();

            const mat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.45, metalness: 0 });
            const mesh = new THREE.Mesh(merged, mat);
            mesh.castShadow = true; mesh.receiveShadow = true;
            scene.add(mesh);
            const no = { id: Date.now(), type: 'merged', name: `${A.name} ‚à™ ${B.name}`, mesh, params: {} };

            removeObjs([A, B]);
            objs.push(no);
            deselectAll(false); selectObj(no, true);
            updateTree(); updateStats();
            toast('–û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ');
        }

        function performSubtract(A, B) {
            const gA = getWorldGeom(A);
            const gB = getWorldGeom(B);
            flipNormals(gB);
            _addVertexColors(gA, A.mesh.material.color, gA.attributes.position.count);
            _addVertexColors(gB, B.mesh.material.color, gB.attributes.position.count);
            const merged = mergeGeomsWithColors(gA, gB);
            merged.computeVertexNormals();

            const mat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.45, metalness: 0 });
            const mesh = new THREE.Mesh(merged, mat);
            mesh.castShadow = true; mesh.receiveShadow = true;
            mesh.material.side = THREE.DoubleSide;
            scene.add(mesh);
            const no = { id: Date.now(), type: 'merged', name: `${A.name} ‚àí ${B.name}`, mesh, params: {} };

            removeObjs([A, B]);
            objs.push(no);
            deselectAll(false); selectObj(no, true);
            updateTree(); updateStats();
            toast('–í—ã—á–∏—Ç–∞–Ω–∏–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ');
        }

        function performIntersect(A, B) {
            const gA = getWorldGeom(A);
            const gB = getWorldGeom(B);

            const m = new THREE.Matrix4().makeScale(0.9, 0.9, 0.9);
            gB.applyMatrix4(m);

            _addVertexColors(gA, A.mesh.material.color, gA.attributes.position.count);
            _addVertexColors(gB, B.mesh.material.color, gB.attributes.position.count);
            const merged = mergeGeomsWithColors(gA, gB);
            merged.computeVertexNormals();

            const mat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.45, metalness: 0 });
            const mesh = new THREE.Mesh(merged, mat);
            mesh.castShadow = true; mesh.receiveShadow = true;
            scene.add(mesh);
            const no = { id: Date.now(), type: 'merged', name: `${A.name} ‚à© ${B.name}`, mesh, params: {} };

            removeObjs([A, B]);
            objs.push(no);
            deselectAll(false); selectObj(no, true);
            updateTree(); updateStats();
            toast('–ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ');
        }

        function flipNormals(geom) {
            const idx = geom.index;
            if (idx) {
                for (let i = 0; i < idx.count; i += 3) {
                    const a = idx.getX(i + 1), b = idx.getX(i + 2);
                    idx.setX(i + 1, b); idx.setX(i + 2, a);
                }
                idx.needsUpdate = true;
            } else {
                const pos = geom.attributes.position.array;
                for (let i = 0; i < pos.length; i += 9) {
                    let tmp;
                    tmp = pos[i + 3]; pos[i + 3] = pos[i + 6]; pos[i + 6] = tmp;
                    tmp = pos[i + 4]; pos[i + 4] = pos[i + 7]; pos[i + 7] = tmp;
                    tmp = pos[i + 5]; pos[i + 5] = pos[i + 8]; pos[i + 8] = tmp;
                }
                geom.attributes.position.needsUpdate = true;
            }
        }

        function mergeGeoms(gA, gB) {
            // Both geometries must already be non-indexed (getWorldGeom ensures this)
            const posA = gA.attributes.position.array;
            const posB = gB.attributes.position.array;
            const norA = gA.attributes.normal ? gA.attributes.normal.array : new Float32Array(posA.length);
            const norB = gB.attributes.normal ? gB.attributes.normal.array : new Float32Array(posB.length);

            const positions = new Float32Array(posA.length + posB.length);
            const normals = new Float32Array(norA.length + norB.length);
            positions.set(posA); positions.set(posB, posA.length);
            normals.set(norA); normals.set(norB, norA.length);

            const g = new THREE.BufferGeometry();
            g.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            g.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
            return g;
        }

        function mergeGeomsWithColors(gA, gB) {
            const posA = gA.attributes.position.array;
            const posB = gB.attributes.position.array;
            const norA = gA.attributes.normal ? gA.attributes.normal.array : new Float32Array(posA.length);
            const norB = gB.attributes.normal ? gB.attributes.normal.array : new Float32Array(posB.length);
            const colA = gA.attributes.color ? gA.attributes.color.array : null;
            const colB = gB.attributes.color ? gB.attributes.color.array : null;

            const positions = new Float32Array(posA.length + posB.length);
            const normals = new Float32Array(norA.length + norB.length);
            positions.set(posA); positions.set(posB, posA.length);
            normals.set(norA); normals.set(norB, norA.length);

            const g = new THREE.BufferGeometry();
            g.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            g.setAttribute('normal', new THREE.BufferAttribute(normals, 3));

            if (colA && colB) {
                const colors = new Float32Array(colA.length + colB.length);
                colors.set(colA); colors.set(colB, colA.length);
                g.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            }
            return g;
        }

        function removeObjs(list) {
            list.forEach(o => { scene.remove(o.mesh); o.mesh.geometry.dispose(); o.mesh.material.dispose(); objs.splice(objs.indexOf(o), 1); });
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  UNDO / REDO
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        function snapshot() {
            return objs.map(o => {
                const mat = o.mesh.material;
                const s = {
                    id: o.id, type: o.type, name: o.name, params: { ...o.params },
                    pos: o.mesh.position.toArray(),
                    rot: [o.mesh.rotation.x, o.mesh.rotation.y, o.mesh.rotation.z],
                    scl: o.mesh.scale.toArray(),
                    color: '#' + mat.color.getHexString(),
                    metalness: mat.metalness || 0,
                    roughness: mat.roughness !== undefined ? mat.roughness : 0.5,
                    opacity: mat.opacity !== undefined ? mat.opacity : 1,
                    wireframe: mat.wireframe || false,
                    vertexColors: mat.vertexColors || false,
                };
                // Save vertex color data for merged objects
                if (mat.vertexColors && o.mesh.geometry.attributes.color) {
                    s.colorData = Array.from(o.mesh.geometry.attributes.color.array);
                    s.posData = Array.from(o.mesh.geometry.attributes.position.array);
                    s.norData = o.mesh.geometry.attributes.normal
                        ? Array.from(o.mesh.geometry.attributes.normal.array) : null;
                }
                return s;
            });
        }

        function restoreSnapshot(state) {
            objs.forEach(o => { scene.remove(o.mesh); o.mesh.geometry.dispose(); o.mesh.material.dispose(); });
            objs = []; sel = []; hideGizmoMesh();

            state.forEach(s => {
                let g, mat;
                const p = s.params;

                if (s.vertexColors && s.posData) {
                    // Restore merged geometry with vertex colors
                    g = new THREE.BufferGeometry();
                    g.setAttribute('position', new THREE.BufferAttribute(new Float32Array(s.posData), 3));
                    if (s.norData) g.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(s.norData), 3));
                    if (s.colorData) g.setAttribute('color', new THREE.BufferAttribute(new Float32Array(s.colorData), 3));
                    mat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: s.roughness || 0.45, metalness: s.metalness || 0, opacity: s.opacity !== undefined ? s.opacity : 1, transparent: (s.opacity || 1) < 1, wireframe: s.wireframe || false });
                } else {
                    if (s.type === 'box') g = new THREE.BoxGeometry(p.w || 1, p.h || 1, p.d || 1);
                    else if (s.type === 'sphere') g = new THREE.SphereGeometry(p.r || 0.5, p.sw || 32, p.sh || 16);
                    else if (s.type === 'cyl') g = new THREE.CylinderGeometry(p.rt || 0.5, p.rb || 0.5, p.h || 1, 32);
                    else if (s.type === 'cone') g = new THREE.ConeGeometry(p.r || 0.5, p.h || 1, p.s || 32);
                    else if (s.type === 'torus') g = new THREE.TorusGeometry(p.r || 0.5, p.t || 0.2, 16, p.s || 32);
                    else if (s.type === 'plane') g = new THREE.PlaneGeometry(p.w || 1, p.h || 1);
                    else g = new THREE.BoxGeometry(1, 1, 1);
                    mat = new THREE.MeshStandardMaterial({ color: new THREE.Color(s.color), metalness: s.metalness || 0, roughness: s.roughness || 0.5, opacity: s.opacity !== undefined ? s.opacity : 1, transparent: (s.opacity || 1) < 1, wireframe: s.wireframe || false });
                }

                const mesh = new THREE.Mesh(g, mat);
                mesh.castShadow = true; mesh.receiveShadow = true;
                mesh.position.fromArray(s.pos); mesh.rotation.set(...s.rot); mesh.scale.fromArray(s.scl);
                scene.add(mesh);
                objs.push({ id: s.id, type: s.type, name: s.name, mesh, params: { ...s.params } });
            });

            updateTree(); updateStats(); updateSelUI();
            document.getElementById('empty-hint').style.display = objs.length === 0 ? 'block' : 'none';
        }

        function saveUndo() {
            undoStack.push(snapshot());
            if (undoStack.length > 50) undoStack.shift();
            redoStack = [];
        }

        function undo() {
            if (!undoStack.length) return;
            redoStack.push(snapshot());
            restoreSnapshot(undoStack.pop());
        }

        function redo() {
            if (!redoStack.length) return;
            undoStack.push(snapshot());
            restoreSnapshot(redoStack.pop());
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  EXPORT
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        //  EXPORT MODAL
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function showExportModal() {
            if (!objs.length) { toast('–ù–µ—Ç –æ–±—ä–µ–∫—Ç–æ–≤'); return; }
            const selCount = sel.length;
            const totalCount = objs.length;
            const scope = selCount > 0 ? `–í—ã–±—Ä–∞–Ω–æ: ${selCount} –æ–±—ä–µ–∫—Ç(–æ–≤)` : `–í—Å–µ –æ–±—ä–µ–∫—Ç—ã: ${totalCount}`;

            const modal = document.createElement('div');
            modal.className = 'modal-bg';
            modal.id = 'export-modal';
            modal.innerHTML = `
                    <div class="modal-box" style="min-width:380px">
                        <h3>–≠–∫—Å–ø–æ—Ä—Ç</h3>
                        <p style="margin-bottom:10px">–û–±–ª–∞—Å—Ç—å: <b style="color:var(--cyan)">${scope}</b></p>
                        <div class="exp-opt" onclick="exportSTL();closeModal('export-modal')">
                            <span class="eo-ico">üìê</span>
                            <div><div class="eo-title">STL</div><div class="eo-desc">–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–ª—è 3D-–ø–µ—á–∞—Ç–∏</div></div>
                        </div>
                        <div class="exp-opt" onclick="exportOBJ();closeModal('export-modal')">
                            <span class="eo-ico">üì¶</span>
                            <div><div class="eo-title">OBJ + MTL</div><div class="eo-desc">Wavefront OBJ —Å –º–∞—Ç–µ—Ä–∏–∞–ª–∞–º–∏</div></div>
                        </div>
                        <div class="exp-opt" onclick="saveProject();closeModal('export-modal')">
                            <span class="eo-ico">üíæ</span>
                            <div><div class="eo-title">–ü—Ä–æ–µ–∫—Ç .r3d</div><div class="eo-desc">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å—Ü–µ–Ω—É –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–≥–æ –æ—Ç–∫—Ä—ã—Ç–∏—è</div></div>
                        </div>
                        <div class="modal-btns" style="margin-top:12px">
                            <button class="mbtn" onclick="closeModal('export-modal')">–û—Ç–º–µ–Ω–∞</button>
                        </div>
                    </div>`;
            document.body.appendChild(modal);
            modal.addEventListener('click', e => { if (e.target === modal) closeModal('export-modal'); });
        }

        function closeModal(id) {
            const el = document.getElementById(id);
            if (el) el.remove();
        }

        function exportSTL() {
            if (!objs.length) { toast('–ù–µ—Ç –æ–±—ä–µ–∫—Ç–æ–≤'); return; }
            const targets = sel.length ? sel : objs;
            let stl = 'solid ren3d\n';

            targets.forEach(obj => {
                const g = obj.mesh.geometry.clone();
                g.applyMatrix4(obj.mesh.matrixWorld);
                g.computeVertexNormals();
                const gi = g.index ? g.toNonIndexed() : g;
                const pos = gi.attributes.position, nor = gi.attributes.normal;
                const n = pos.count;
                for (let i = 0; i < n; i += 3) {
                    const nx = nor ? nor.getX(i) : 0, ny = nor ? nor.getY(i) : 1, nz = nor ? nor.getZ(i) : 0;
                    stl += `  facet normal ${nx.toFixed(6)} ${ny.toFixed(6)} ${nz.toFixed(6)}\n    outer loop\n`;
                    for (let v = 0; v < 3; v++) stl += `      vertex ${pos.getX(i + v).toFixed(6)} ${pos.getY(i + v).toFixed(6)} ${pos.getZ(i + v).toFixed(6)}\n`;
                    stl += `    endloop\n  endfacet\n`;
                }
            });
            stl += 'endsolid ren3d';
            download('ren3d.stl', stl);
            toast('–≠–∫—Å–ø–æ—Ä—Ç .stl –≥–æ—Ç–æ–≤!');
            closeAllMenus();
        }

        function exportOBJ() {
            if (!objs.length) { toast('–ù–µ—Ç –æ–±—ä–µ–∫—Ç–æ–≤'); return; }
            const targets = sel.length ? sel : objs;
            let obj = '# Ren3D v2.0\n\n';
            let off = 1;

            targets.forEach((o, i) => {
                const g = o.mesh.geometry.clone();
                g.applyMatrix4(o.mesh.matrixWorld);
                g.computeVertexNormals();
                const gi = g.index ? g.toNonIndexed() : g;
                const pos = gi.attributes.position, nor = gi.attributes.normal;
                obj += `g ${o.name.replace(/ /g, '_')}\n`;
                for (let v = 0; v < pos.count; v++) obj += `v ${pos.getX(v).toFixed(6)} ${pos.getY(v).toFixed(6)} ${pos.getZ(v).toFixed(6)}\n`;
                if (nor) for (let v = 0; v < nor.count; v++) obj += `vn ${nor.getX(v).toFixed(6)} ${nor.getY(v).toFixed(6)} ${nor.getZ(v).toFixed(6)}\n`;
                for (let v = 0; v < pos.count; v += 3) {
                    const a = v + off, b = v + 1 + off, c = v + 2 + off;
                    obj += nor ? `f ${a}//${a} ${b}//${b} ${c}//${c}\n` : `f ${a} ${b} ${c}\n`;
                }
                off += pos.count; obj += '\n';
            });
            download('ren3d.obj', obj);
            toast('–≠–∫—Å–ø–æ—Ä—Ç .obj –≥–æ—Ç–æ–≤!');
            closeAllMenus();
        }

        function download(name, content) {
            if (window.electronAPI && window.electronAPI.saveFile) {
                window.electronAPI.saveFile(name, content).then(res => {
                    if (res && res.ok) toast('–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ: ' + res.filePath.split(/[\/]/).pop());
                });
            } else {
                const a = document.createElement('a');
                a.href = URL.createObjectURL(new Blob([content], { type: 'text/plain' }));
                a.download = name; a.click();
                URL.revokeObjectURL(a.href);
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  IMPORT
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        function doImport() { document.getElementById('file-in').click(); closeAllMenus(); }

        function handleFile(e) {
            const f = e.target.files[0]; if (!f) return;
            const ext = f.name.split('.').pop().toLowerCase();
            const r = new FileReader();
            r.onload = ev => {
                try {
                    if (ext === 'stl') importSTL(ev.target.result, f.name);
                    else if (ext === 'obj') importOBJ(ev.target.result, f.name);
                    toast(`–ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ: ${f.name}`);
                } catch (er) { toast('–û—à–∏–±–∫–∞: ' + er.message); }
            };
            ext === 'stl' ? r.readAsArrayBuffer(f) : r.readAsText(f);
            e.target.value = '';
        }

        function importSTL(buf, name) {
            saveUndo();
            let g;
            const arr = new Uint8Array(buf, 0, Math.min(80, buf.byteLength));
            const isAscii = !arr.some(b => b > 127);

            if (isAscii) {
                g = parseSTLASCII(new TextDecoder().decode(buf));
            } else {
                g = parseSTLBin(buf);
            }
            g.computeVertexNormals(); g.computeBoundingBox(); g.center();

            const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color(PALETTE[ci % PALETTE.length]), roughness: 0.45, metalness: 0 });
            ci++;
            const mesh = new THREE.Mesh(g, mat);
            mesh.castShadow = true; mesh.receiveShadow = true; mesh.position.y = 0.5;
            scene.add(mesh);
            const no = { id: Date.now(), type: 'imported', name: name.replace('.stl', ''), mesh, params: {} };
            objs.push(no);
            updateTree(); updateStats();
            deselectAll(false); selectObj(no, true); frameObjs([mesh]);
            document.getElementById('empty-hint').style.display = 'none';
        }

        function parseSTLASCII(txt) {
            const verts = [], norms = [];
            let nx = 0, ny = 0, nz = 0;
            for (const ln of txt.split('\n')) {
                const t = ln.trim();
                if (t.startsWith('facet normal')) { const p = t.split(/\s+/); nx = +p[2]; ny = +p[3]; nz = +p[4]; }
                else if (t.startsWith('vertex')) { const p = t.split(/\s+/); verts.push(+p[1], +p[2], +p[3]); norms.push(nx, ny, nz); }
            }
            const g = new THREE.BufferGeometry();
            g.setAttribute('position', new THREE.BufferAttribute(new Float32Array(verts), 3));
            g.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(norms), 3));
            return g;
        }

        function parseSTLBin(buf) {
            const view = new DataView(buf);
            const nf = view.getUint32(80, true);
            const verts = new Float32Array(nf * 9), norms = new Float32Array(nf * 9);
            let off = 84;
            for (let i = 0; i < nf; i++) {
                const nx = view.getFloat32(off, true), ny = view.getFloat32(off + 4, true), nz = view.getFloat32(off + 8, true);
                off += 12;
                for (let v = 0; v < 3; v++) {
                    const vi = i * 9 + v * 3;
                    verts[vi] = view.getFloat32(off, true); verts[vi + 1] = view.getFloat32(off + 4, true); verts[vi + 2] = view.getFloat32(off + 8, true);
                    norms[vi] = nx; norms[vi + 1] = ny; norms[vi + 2] = nz;
                    off += 12;
                }
                off += 2;
            }
            const g = new THREE.BufferGeometry();
            g.setAttribute('position', new THREE.BufferAttribute(verts, 3));
            g.setAttribute('normal', new THREE.BufferAttribute(norms, 3));
            return g;
        }

        function importOBJ(txt, name) {
            saveUndo();
            const verts = [], norms = [], fverts = [], fnorms = [];
            for (const ln of txt.split('\n')) {
                const t = ln.trim();
                if (t.startsWith('v ')) { const p = t.split(/\s+/); verts.push([+p[1], +p[2], +p[3]]); }
                else if (t.startsWith('vn ')) { const p = t.split(/\s+/); norms.push([+p[1], +p[2], +p[3]]); }
                else if (t.startsWith('f ')) {
                    const parts = t.split(/\s+/).slice(1).map(p => { const x = p.split('/'); return { v: +x[0] - 1, n: x[2] ? +x[2] - 1 : -1 }; });
                    for (let i = 1; i < parts.length - 1; i++) {
                        [parts[0], parts[i], parts[i + 1]].forEach(fv => {
                            fverts.push(...(verts[fv.v] || [0, 0, 0]));
                            fnorms.push(...(fv.n >= 0 && norms[fv.n] ? norms[fv.n] : [0, 1, 0]));
                        });
                    }
                }
            }
            const g = new THREE.BufferGeometry();
            g.setAttribute('position', new THREE.BufferAttribute(new Float32Array(fverts), 3));
            g.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(fnorms), 3));
            g.computeVertexNormals(); g.computeBoundingBox(); g.center();

            const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color(PALETTE[ci % PALETTE.length]), roughness: 0.45, metalness: 0 });
            ci++;
            const mesh = new THREE.Mesh(g, mat);
            mesh.castShadow = true; mesh.receiveShadow = true; mesh.position.y = 0.5;
            scene.add(mesh);
            const no = { id: Date.now(), type: 'imported', name: name.replace('.obj', ''), mesh, params: {} };
            objs.push(no);
            updateTree(); updateStats();
            deselectAll(false); selectObj(no, true); frameObjs([mesh]);
            document.getElementById('empty-hint').style.display = 'none';
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  PROJECT SAVE / OPEN
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        function saveProject() {
            if (!objs.length) { toast('–ù–µ—Ç –æ–±—ä–µ–∫—Ç–æ–≤ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è'); return; }
            const data = {
                version: 1,
                name: 'Ren3D Project',
                saved: new Date().toISOString(),
                objects: snapshot(),
            };
            const json = JSON.stringify(data, null, 2);
            if (window.electronAPI && window.electronAPI.saveFile) {
                window.electronAPI.saveFile('project.r3d', json).then(res => {
                    if (res && res.ok) toast('–ü—Ä–æ–µ–∫—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω: ' + res.filePath.split(/[\/]/).pop());
                });
            } else {
                const a = document.createElement('a');
                a.href = URL.createObjectURL(new Blob([json], { type: 'application/json' }));
                a.download = 'project.r3d'; a.click();
                URL.revokeObjectURL(a.href);
                toast('–ü—Ä–æ–µ–∫—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω!');
            }
            closeAllMenus();
        }

        function openProject() {
            document.getElementById('proj-in').click();
            closeAllMenus();
        }

        function handleProjectOpen(e) {
            const f = e.target.files[0]; if (!f) return;
            const r = new FileReader();
            r.onload = ev => {
                try {
                    const data = JSON.parse(ev.target.result);
                    if (!data.objects) throw new Error('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞');
                    if (objs.length && !confirm('–û—Ç–∫—Ä—ã—Ç—å –ø—Ä–æ–µ–∫—Ç? –¢–µ–∫—É—â–∞—è —Å—Ü–µ–Ω–∞ –±—É–¥–µ—Ç –∑–∞–∫—Ä—ã—Ç–∞.')) return;
                    // Clear scene
                    objs.forEach(o => { scene.remove(o.mesh); o.mesh.geometry.dispose(); o.mesh.material.dispose(); });
                    objs = []; sel = []; undoStack = []; redoStack = []; hideGizmoMesh();
                    // Restore
                    restoreSnapshot(data.objects);
                    // Restore counter
                    counter = {};
                    objs.forEach(o => { if (!counter[o.type]) counter[o.type] = 0; counter[o.type]++; });
                    document.getElementById('empty-hint').style.display = objs.length ? 'none' : 'block';
                    toast('–ü—Ä–æ–µ–∫—Ç –æ—Ç–∫—Ä—ã—Ç: ' + f.name);
                    if (objs.length) frameAll();
                } catch (err) { toast('–û—à–∏–±–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è –ø—Ä–æ–µ–∫—Ç–∞: ' + err.message); }
            };
            r.readAsText(f);
            e.target.value = '';
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  NEW SCENE
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        function newScene() {
            if (objs.length && !confirm('–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é —Å—Ü–µ–Ω—É? –ò–∑–º–µ–Ω–µ–Ω–∏—è –±—É–¥—É—Ç –ø–æ—Ç–µ—Ä—è–Ω—ã.')) return;
            objs.forEach(o => { scene.remove(o.mesh); o.mesh.geometry.dispose(); o.mesh.material.dispose(); });
            objs = []; sel = []; undoStack = []; redoStack = []; hideGizmoMesh();
            updateTree(); updateStats(); updateSelUI();
            document.getElementById('empty-hint').style.display = 'block';
            closeAllMenus();
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  RESIZABLE PANELS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        function initResizablePanels() {
            const app = document.getElementById('app');

            function makeResizable(handleEl, side) {
                let startX, startW;
                handleEl.addEventListener('mousedown', e => {
                    startX = e.clientX;
                    const panel = side === 'left'
                        ? document.getElementById('left')
                        : document.getElementById('right');
                    startW = panel.getBoundingClientRect().width;
                    handleEl.classList.add('dragging');
                    document.body.style.cursor = 'col-resize';
                    document.body.style.userSelect = 'none';

                    const onMove = e => {
                        const dx = e.clientX - startX;
                        const newW = side === 'left'
                            ? Math.max(160, Math.min(400, startW + dx))
                            : Math.max(160, Math.min(400, startW - dx));
                        app.style.gridTemplateColumns = side === 'left'
                            ? `${newW}px 1fr var(--panel-w)`
                            : `var(--panel-w) 1fr ${newW}px`;
                        if (side === 'left') app.style.setProperty('--panel-w-left', newW + 'px');
                    };
                    const onUp = () => {
                        handleEl.classList.remove('dragging');
                        document.body.style.cursor = '';
                        document.body.style.userSelect = '';
                        document.removeEventListener('mousemove', onMove);
                        document.removeEventListener('mouseup', onUp);
                        resize();
                    };
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onUp);
                    e.preventDefault();
                });
            }

            // Insert resize handles dynamically next to panels
            const left = document.getElementById('left');
            const right = document.getElementById('right');
            const vp = document.getElementById('vp');

            const lHandle = document.createElement('div');
            lHandle.className = 'panel-resize-handle';
            lHandle.title = '–¢–∞—â–∏ –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è —à–∏—Ä–∏–Ω—ã';
            left.parentNode.insertBefore(lHandle, vp);
            makeResizable(lHandle, 'left');

            const rHandle = document.createElement('div');
            rHandle.className = 'panel-resize-handle';
            rHandle.title = '–¢–∞—â–∏ –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è —à–∏—Ä–∏–Ω—ã';
            vp.parentNode.insertBefore(rHandle, right);
            makeResizable(rHandle, 'right');
        }

        //  KEYBOARD ‚Äî FIX –¥–ª—è Linux
        //  –ö–ª—é—á–µ–≤—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è:
        //  1. capture=true –≤ addEventListener (—Å–º. init())
        //  2. e.key.toLowerCase() –≤–µ–∑–¥–µ ‚Äî –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ—Ç —Ä–µ–≥–∏—Å—Ç—Ä –Ω–∞ Linux
        //  3. e.code –¥–ª—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ ‚Äî –Ω–µ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ä–∞—Å–∫–ª–∞–¥–∫–∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
        //  4. e.preventDefault() –≤ Shift-–±–ª–æ–∫–µ ‚Äî –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç —Å–∏—Å—Ç–µ–º–Ω—ã–µ –∫–æ–Ω—Ñ–ª–∏–∫—Ç—ã
        //  5. –ò—Å–ø—Ä–∞–≤–ª–µ–Ω –¥—É–±–ª–∏—Ä—É—é—â–∏–π—Å—è case 'j' (–±—ã–ª —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∏–π –±–∞–≥)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        function onKey(e) {
            // –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å –µ—Å–ª–∏ —Ñ–æ–∫—É—Å –≤ –ø–æ–ª–µ –≤–≤–æ–¥–∞
            const tag = e.target.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            // FIX: –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ–º —Ä–µ–≥–∏—Å—Ç—Ä ‚Äî –Ω–∞ Linux Shift+C –º–æ–∂–µ—Ç –¥–∞—Ç—å 'c' –∏–ª–∏ 'C' –Ω–µ–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ
            const key = e.key.toLowerCase();

            if (e.ctrlKey || e.metaKey) {
                switch (key) {
                    case 'z': e.preventDefault(); undo(); return;
                    case 'y': e.preventDefault(); redo(); return;
                    case 'd': e.preventDefault(); duplicateSel(); return;
                    case 'a': e.preventDefault(); selectAll(); return;
                    case 'i': e.preventDefault(); doImport(); return;
                    case 'e': e.preventDefault(); showExportModal(); return;
                    case 'n': e.preventDefault(); newScene(); return;
                    case 's': e.preventDefault(); saveProject(); return;
                    case 'o': e.preventDefault(); openProject(); return;
                    case 'j':
                        e.preventDefault();
                        if (e.shiftKey) { boolOp('subtract'); } else { boolOp('union'); }
                        return;
                }
                return;
            }

            if (e.shiftKey) {
                switch (key) {
                    // FIX: e.preventDefault() –±–ª–æ–∫–∏—Ä—É–µ—Ç —Å–∏—Å—Ç–µ–º–Ω—ã–µ Shift-–∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ –Ω–∞ Linux
                    case 'c': e.preventDefault(); addObj('box'); return;
                    case 's': e.preventDefault(); addObj('sphere'); return;
                    case 'y': e.preventDefault(); addObj('cyl'); return;
                    case 'o': e.preventDefault(); addObj('cone'); return;
                    case 't': e.preventDefault(); addObj('torus'); return;
                    case 'p': e.preventDefault(); addObj('plane'); return;
                }
                return;
            }

            switch (key) {
                case 'delete':
                case 'backspace': deleteSel(); break;
                case 'escape': deselectAll(); break;
                case 'f': frameSel(); break;
                case 'g': toggleGrid(); break;
                case 'z': toggleWire(); break;
                case 'home': frameAll(); break;
            }

            // FIX: e.code –¥–ª—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ ‚Äî —Ñ–∏–∑–∏—á–µ—Å–∫–∏–π –∫–æ–¥ –∫–ª–∞–≤–∏—à–∏,
            // –Ω–µ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ä–∞—Å–∫–ª–∞–¥–∫–∏ –∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞ –Ω–∞ –ª—é–±–æ–π –û–°
            if (!e.shiftKey && !e.ctrlKey && !e.metaKey && !e.altKey) {
                switch (e.code) {
                    case 'KeyQ': setTool('sel'); break;
                    case 'KeyG': setTool('move'); break;
                    case 'KeyR': setTool('rot'); break;
                    case 'KeyS': setTool('scale'); break;
                }
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  ORIENTATION GIZMO (canvas corner)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        function drawOriGizmo() {
            const cvs = document.getElementById('gizmo-cnv');
            const ctx = cvs.getContext('2d');
            const W = cvs.width, H = cvs.height, cx = W / 2, cy = H / 2, r = W / 2 - 6;
            ctx.clearRect(0, 0, W, H);

            ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(5,5,8,0.55)'; ctx.fill();
            ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth = 1; ctx.stroke();

            const mat = new THREE.Matrix4().extractRotation(camera.matrixWorldInverse);
            const axes = [
                { v: new THREE.Vector3(1, 0, 0), c: '#ff4466', l: 'X' },
                { v: new THREE.Vector3(0, 1, 0), c: '#44ff88', l: 'Y' },
                { v: new THREE.Vector3(0, 0, 1), c: '#4499ff', l: 'Z' },
                { v: new THREE.Vector3(-1, 0, 0), c: '#882233', l: '' },
                { v: new THREE.Vector3(0, -1, 0), c: '#226644', l: '' },
                { v: new THREE.Vector3(0, 0, -1), c: '#224488', l: '' },
            ];
            const proj = axes.map(a => {
                const v = a.v.clone().applyMatrix4(mat);
                return { x: cx + v.x * r * .8, y: cy - v.y * r * .8, z: v.z, c: a.c, l: a.l };
            }).sort((a, b) => a.z - b.z);

            proj.forEach(p => {
                ctx.globalAlpha = p.z > 0 ? 1 : 0.35;
                ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(p.x, p.y);
                ctx.strokeStyle = p.c; ctx.lineWidth = p.z > 0 ? 2 : 1; ctx.stroke();
                ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fillStyle = p.c; ctx.fill();
                if (p.l) { ctx.fillStyle = 'rgba(255,255,255,0.85)'; ctx.font = `${p.z > 0 ? 'bold ' : ''}7px Fira Code`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(p.l, p.x, p.y); }
                ctx.globalAlpha = 1;
            });
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  MENUS / UI HELPERS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        function openMenu(name, btn) {
            const dd = document.getElementById('dd-' + name);
            const wasOpen = dd.classList.contains('open');
            closeAllMenus();
            if (!wasOpen) { dd.classList.add('open'); btn.classList.add('open'); }
            event.stopPropagation();
        }

        function closeMenus() { closeAllMenus(); }
        function closeAllMenus() {
            document.querySelectorAll('.dropdown').forEach(d => d.classList.remove('open'));
            document.querySelectorAll('.menu-trigger').forEach(b => b.classList.remove('open'));
        }

        function toggleSec(hdr) {
            const body = hdr.nextElementSibling;
            if (!body) return;
            const hidden = body.style.display === 'none';
            body.style.display = hidden ? '' : ' none';
            if (!hidden) body.style.display = 'none';
            hdr.classList.toggle('coll', !hidden);
        }

        // Context menu
        function onCtx(e) {
            e.preventDefault();
            updateMouse(e);
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(objs.map(o => o.mesh));

            const multiSel = sel.length >= 2;
            const items = hits.length ? `
            <div class="ctx-it" onclick="duplicateSel();closeCtx()">–î—É–±–ª–∏—Ä–æ–≤–∞—Ç—å <span style="color:var(--ink-dim)">Ctrl+D</span></div>
            <div class="ctx-it" onclick="frameSel();closeCtx()">–§–æ–∫—É—Å <span style="color:var(--ink-dim)">F</span></div>
            ${multiSel ? `<div class="ctx-sep"></div>
            <div class="ctx-it" onclick="boolOp('union');closeCtx()">‚äï –û–±—ä–µ–¥–∏–Ω–∏—Ç—å <span style="color:var(--ink-dim)">Ctrl+J</span></div>
            <div class="ctx-it" onclick="boolOp('subtract');closeCtx()">‚äñ –í—ã—á–µ—Å—Ç—å <span style="color:var(--ink-dim)">Ctrl+Shift+J</span></div>
            <div class="ctx-it" onclick="boolOp('intersect');closeCtx()">‚äó –ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ</div>` : ''}
            <div class="ctx-sep"></div>
            <div class="ctx-it danger" onclick="deleteSel();closeCtx()">–£–¥–∞–ª–∏—Ç—å <span style="color:var(--ink-dim)">Del</span></div>
          ` : `
            <div class="ctx-it" onclick="addObj('box');closeCtx()">‚¨õ –î–æ–±–∞–≤–∏—Ç—å –∫—É–±</div>
            <div class="ctx-it" onclick="addObj('sphere');closeCtx()">üîµ –î–æ–±–∞–≤–∏—Ç—å —Å—Ñ–µ—Ä—É</div>
            <div class="ctx-it" onclick="addObj('cyl');closeCtx()">üî∑ –¶–∏–ª–∏–Ω–¥—Ä</div>
            <div class="ctx-sep"></div>
            <div class="ctx-it" onclick="doImport();closeCtx()">‚á™ –ò–º–ø–æ—Ä—Ç –º–æ–¥–µ–ª–∏</div>
          `;

            let ctx = document.getElementById('ren-ctx');
            if (!ctx) { ctx = document.createElement('div'); ctx.className = 'ctx'; ctx.id = 'ren-ctx'; document.body.appendChild(ctx); }
            ctx.innerHTML = items;
            ctx.style.left = Math.min(e.clientX, window.innerWidth - 180) + 'px';
            ctx.style.top = Math.min(e.clientY, window.innerHeight - 160) + 'px';
            ctx.style.display = 'block';
            setTimeout(() => document.addEventListener('click', closeCtx, { once: true }), 50);
        }

        function closeCtx() { const c = document.getElementById('ren-ctx'); if (c) c.style.display = 'none'; }

        // Toast
        let toastTimer;
        function toast(msg) {
            const el = document.getElementById('toast');
            el.textContent = msg; el.style.opacity = '1';
            clearTimeout(toastTimer);
            toastTimer = setTimeout(() => el.style.opacity = '0', 2800);
        }

        // ‚îÄ‚îÄ Start ‚îÄ‚îÄ
        window.addEventListener('load', init);
        window.addEventListener('resize', resize);

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  AUTO-UPDATER
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        const APP_VERSION = '2.1.0';
        const GITHUB_USER = 'MihailKashintsev';
        const GITHUB_REPO = 'ren3d';
        const GITHUB_BRANCH = 'master';
        const VERSION_URL = `https://raw.githubusercontent.com/${GITHUB_USER}/${GITHUB_REPO}/${GITHUB_BRANCH}/app/version.json`;
        const APP_URL = `https://raw.githubusercontent.com/${GITHUB_USER}/${GITHUB_REPO}/${GITHUB_BRANCH}/app/src/index.html`;

        (function injectUpdateStyles() {
            const s = document.createElement('style');
            s.textContent = `
            #update-banner {
              position: fixed;
              bottom: 32px; left: 50%; transform: translateX(-50%);
              background: rgba(0,212,255,0.12);
              border: 1px solid rgba(0,212,255,0.35);
              backdrop-filter: blur(20px);
              border-radius: 12px;
              padding: 14px 22px;
              display: flex; align-items: center; gap: 14px;
              color: rgba(255,255,255,0.92);
              font-family: 'Syne', sans-serif;
              font-size: 13px;
              z-index: 99999;
              box-shadow: 0 8px 32px rgba(0,0,0,0.5), 0 0 20px rgba(0,212,255,0.15);
              opacity: 0; pointer-events: none;
              transition: opacity 0.4s ease;
            }
            #update-banner.visible { opacity: 1; pointer-events: all; }
            #update-banner .upd-icon { font-size: 18px; }
            #update-banner .upd-text { flex: 1; }
            #update-banner .upd-version { color: #00d4ff; font-weight: 600; }
            #update-banner .upd-btn {
              background: rgba(0,212,255,0.2);
              border: 1px solid rgba(0,212,255,0.4);
              border-radius: 7px;
              color: #00d4ff;
              font-family: 'Syne', sans-serif;
              font-size: 12px; font-weight: 600;
              padding: 6px 14px; cursor: pointer;
              transition: background 0.2s;
            }
            #update-banner .upd-btn:hover { background: rgba(0,212,255,0.35); }
            #update-banner .upd-btn.upd-dismiss {
              background: transparent; border-color: rgba(255,255,255,0.15);
              color: rgba(255,255,255,0.4);
            }
            #update-banner .upd-btn.upd-dismiss:hover { color: rgba(255,255,255,0.7); }
            #update-progress {
              position: fixed; bottom: 0; left: 0; right: 0;
              height: 3px; background: rgba(0,212,255,0.15);
              z-index: 99999; opacity: 0; transition: opacity 0.3s;
            }
            #update-progress-bar {
              height: 100%; width: 0%;
              background: linear-gradient(90deg, #00d4ff, #4499ff);
              transition: width 0.3s ease;
            }
          `;
            document.head.appendChild(s);

            const banner = document.createElement('div');
            banner.id = 'update-banner';
            banner.innerHTML = `
            <span class="upd-icon">üîÑ</span>
            <span class="upd-text">
              New version available: <span class="upd-version" id="upd-new-ver"></span>
              &nbsp;¬∑&nbsp; Current: <span style="color:rgba(255,255,255,0.45)">${APP_VERSION}</span>
            </span>
            <button class="upd-btn" id="upd-install-btn" onclick="installUpdate()">Update now</button>
            <button class="upd-btn upd-dismiss" onclick="dismissUpdate()">Later</button>
          `;
            document.body.appendChild(banner);

            const prog = document.createElement('div');
            prog.id = 'update-progress';
            prog.innerHTML = '<div id="update-progress-bar"></div>';
            document.body.appendChild(prog);
        })();

        function showUpdateBanner(newVersion) {
            document.getElementById('upd-new-ver').textContent = newVersion;
            document.getElementById('update-banner').classList.add('visible');
        }

        function dismissUpdate() {
            document.getElementById('update-banner').classList.remove('visible');
        }

        async function installUpdate() {
            const banner = document.getElementById('update-banner');
            const btn = document.getElementById('upd-install-btn');
            const prog = document.getElementById('update-progress');
            const bar = document.getElementById('update-progress-bar');

            btn.textContent = 'Downloading...';
            btn.disabled = true;
            prog.style.opacity = '1';
            bar.style.width = '15%';

            try {
                const resp = await fetch(APP_URL + '?t=' + Date.now());
                if (!resp.ok) throw new Error('Download failed: ' + resp.status);

                bar.style.width = '60%';
                const html = await resp.text();
                bar.style.width = '85%';

                if (window.electronAPI && window.electronAPI.updateApp) {
                    const result = await window.electronAPI.updateApp(html);
                    if (result.ok) {
                        bar.style.width = '100%';
                        btn.textContent = 'Restarting...';
                        setTimeout(() => window.electronAPI.reloadApp(), 800);
                    } else {
                        throw new Error(result.error || 'Save failed');
                    }
                } else {
                    bar.style.width = '100%';
                    banner.innerHTML = '<span class="upd-icon">‚úì</span><span class="upd-text">Updated! Please refresh the page.</span>';
                }
            } catch (err) {
                bar.style.opacity = '0';
                btn.textContent = 'Update now';
                btn.disabled = false;
                banner.querySelector('.upd-text').innerHTML =
                    '<span style="color:#ff4466">Update failed: ' + err.message + '</span>';
                setTimeout(() => {
                    banner.querySelector('.upd-text').innerHTML =
                        'New version: <span class="upd-version">' +
                        document.getElementById('upd-new-ver').textContent + '</span>';
                }, 3000);
            }
        }

        async function checkForUpdates() {
            try {
                const resp = await fetch(VERSION_URL + '?t=' + Date.now(), {
                    signal: AbortSignal.timeout(8000)
                });
                if (!resp.ok) return;

                const data = await resp.json();
                const latest = data.version;

                if (latest && latest !== APP_VERSION && isNewerVersion(latest, APP_VERSION)) {
                    console.log(`[Ren3D] Update available: ${APP_VERSION} ‚Üí ${latest}`);
                    showUpdateBanner(latest);
                } else {
                    console.log(`[Ren3D] Up to date (${APP_VERSION})`);
                }
            } catch (e) {
                console.log('[Ren3D] Update check skipped:', e.message);
            }
        }

        function isNewerVersion(latest, current) {
            const parse = v => v.replace(/^v/, '').split('.').map(Number);
            const [la, lb, lc] = parse(latest);
            const [ca, cb, cc] = parse(current);
            if (la !== ca) return la > ca;
            if (lb !== cb) return lb > cb;
            return lc > cc;
        }

        window.addEventListener('load', () => {
            setTimeout(checkForUpdates, 3000);
        });
    </script>
</body>
</html>