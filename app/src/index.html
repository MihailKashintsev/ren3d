<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ren3D</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Syne:wght@400;500;600;700;800&family=Fira+Code:wght@300;400;500&display=swap');

:root {
  --void: #050508;
  --glass-bg: rgba(255,255,255,0.04);
  --glass-bg-hover: rgba(255,255,255,0.07);
  --glass-border: rgba(255,255,255,0.08);
  --glass-border-active: rgba(255,255,255,0.18);
  --glass-shadow: 0 8px 32px rgba(0,0,0,0.5);
  --blur: blur(20px);
  --blur-sm: blur(12px);

  --ink: rgba(255,255,255,0.92);
  --ink-mid: rgba(255,255,255,0.45);
  --ink-dim: rgba(255,255,255,0.18);
  --ink-ghost: rgba(255,255,255,0.07);

  --cyan: #00d4ff;
  --cyan-dim: rgba(0,212,255,0.15);
  --cyan-glow: 0 0 20px rgba(0,212,255,0.35);
  --orange: #ff6b35;
  --orange-dim: rgba(255,107,53,0.15);
  --green: #39ff8f;
  --red: #ff4466;
  --purple: #b78bff;
  --yellow: #ffe066;

  --ax: #ff5566;
  --ay: #44ff88;
  --az: #4499ff;

  --panel-w: 220px;
  --topbar-h: 44px;
  --statusbar-h: 22px;
  --r: 10px;
  --r-sm: 6px;
}

* { box-sizing: border-box; margin: 0; padding: 0; }

body {
  background: var(--void);
  color: var(--ink);
  font-family: 'Fira Code', monospace;
  font-size: 11px;
  overflow: hidden;
  height: 100vh;
  width: 100vw;
  cursor: default;
}

/* â”€â”€ NOISE GRAIN OVERLAY â”€â”€ */
body::before {
  content: '';
  position: fixed;
  inset: 0;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.04'/%3E%3C/svg%3E");
  pointer-events: none;
  z-index: 9999;
  opacity: 0.6;
}

/* â”€â”€ GRID BG â”€â”€ */
body::after {
  content: '';
  position: fixed;
  inset: 0;
  background-image:
    linear-gradient(rgba(255,255,255,0.025) 1px, transparent 1px),
    linear-gradient(90deg, rgba(255,255,255,0.025) 1px, transparent 1px);
  background-size: 40px 40px;
  pointer-events: none;
  z-index: 0;
}

/* â”€â”€ LAYOUT â”€â”€ */
#app {
  position: fixed;
  inset: 0;
  display: grid;
  grid-template-rows: var(--topbar-h) 1fr var(--statusbar-h);
  grid-template-columns: var(--panel-w) 1fr var(--panel-w);
  z-index: 1;
}

/* â”€â”€ GLASS PANEL BASE â”€â”€ */
.glass {
  background: var(--glass-bg);
  backdrop-filter: var(--blur);
  -webkit-backdrop-filter: var(--blur);
  border: 1px solid var(--glass-border);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   TOPBAR
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#topbar {
  grid-column: 1 / -1;
  background: rgba(5,5,8,0.85);
  backdrop-filter: var(--blur);
  -webkit-backdrop-filter: var(--blur);
  border-bottom: 1px solid var(--glass-border);
  display: flex;
  align-items: center;
  padding: 0 16px;
  gap: 6px;
  position: relative;
  z-index: 100;
}

.logo {
  font-family: 'Syne', sans-serif;
  font-size: 15px;
  font-weight: 800;
  letter-spacing: 0.12em;
  color: var(--cyan);
  text-shadow: var(--cyan-glow);
  margin-right: 12px;
  display: flex;
  align-items: center;
  gap: 7px;
}
.logo-mark {
  width: 22px; height: 22px;
  border: 2px solid var(--cyan);
  border-radius: 5px;
  display: flex; align-items: center; justify-content: center;
  font-size: 11px;
  box-shadow: var(--cyan-glow), inset 0 0 8px rgba(0,212,255,0.1);
  animation: logoBreath 3s ease-in-out infinite;
}
@keyframes logoBreath {
  0%,100% { box-shadow: var(--cyan-glow), inset 0 0 8px rgba(0,212,255,0.1); }
  50% { box-shadow: 0 0 30px rgba(0,212,255,0.5), inset 0 0 12px rgba(0,212,255,0.15); }
}

.menu-wrap { position: relative; }
.menu-trigger {
  padding: 5px 10px;
  background: transparent;
  border: 1px solid transparent;
  border-radius: var(--r-sm);
  color: var(--ink-mid);
  cursor: pointer;
  font-family: 'Fira Code', monospace;
  font-size: 11px;
  transition: all 0.15s;
  white-space: nowrap;
}
.menu-trigger:hover { background: var(--glass-bg); border-color: var(--glass-border); color: var(--ink); }
.menu-trigger.open { background: var(--glass-bg-hover); border-color: var(--glass-border-active); color: var(--ink); }

.dropdown {
  position: absolute;
  top: calc(100% + 6px);
  left: 0;
  background: rgba(8,8,14,0.95);
  backdrop-filter: var(--blur);
  border: 1px solid var(--glass-border-active);
  border-radius: var(--r);
  min-width: 210px;
  z-index: 999;
  display: none;
  padding: 5px;
  box-shadow: 0 16px 48px rgba(0,0,0,0.8), 0 0 1px rgba(255,255,255,0.05);
}
.dropdown.open { display: block; animation: dropIn 0.15s ease; }
@keyframes dropIn { from { opacity:0; transform:translateY(-4px); } to { opacity:1; transform:translateY(0); } }

.dd-item {
  padding: 6px 10px;
  cursor: pointer;
  border-radius: var(--r-sm);
  display: flex;
  justify-content: space-between;
  align-items: center;
  color: var(--ink-mid);
  transition: all 0.1s;
  font-size: 11px;
}
.dd-item:hover { background: var(--glass-bg-hover); color: var(--ink); }
.dd-item .ks { color: var(--ink-dim); font-size: 10px; }
.dd-sep { height: 1px; background: var(--glass-border); margin: 4px 0; }

.tb-sep { width: 1px; height: 18px; background: var(--glass-border); margin: 0 4px; }
.spacer { flex: 1; }

/* Tool buttons */
.tb-group { display: flex; gap: 2px; }
.tb-btn {
  width: 30px; height: 28px;
  background: transparent;
  border: 1px solid transparent;
  border-radius: var(--r-sm);
  color: var(--ink-mid);
  cursor: pointer;
  display: flex; align-items: center; justify-content: center;
  font-size: 13px;
  transition: all 0.15s;
  position: relative;
}
.tb-btn:hover { background: var(--glass-bg); color: var(--ink); border-color: var(--glass-border); }
.tb-btn.active {
  background: var(--cyan-dim);
  color: var(--cyan);
  border-color: rgba(0,212,255,0.3);
  box-shadow: 0 0 10px rgba(0,212,255,0.2);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   LEFT PANEL
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#left {
  background: rgba(5,5,8,0.7);
  backdrop-filter: var(--blur);
  border-right: 1px solid var(--glass-border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.panel-title {
  font-family: 'Syne', sans-serif;
  font-size: 9px;
  font-weight: 700;
  letter-spacing: 0.18em;
  text-transform: uppercase;
  color: var(--ink-dim);
  padding: 10px 12px 6px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

/* PRIMITIVES */
.prim-grid {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 3px;
  padding: 0 8px 8px;
}
.prim-btn {
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  border-radius: var(--r-sm);
  padding: 8px 4px 6px;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  color: var(--ink-mid);
  transition: all 0.2s;
  font-family: 'Fira Code', monospace;
  font-size: 9px;
}
.prim-btn:hover {
  background: var(--glass-bg-hover);
  border-color: var(--glass-border-active);
  color: var(--ink);
  transform: translateY(-1px);
  box-shadow: 0 4px 16px rgba(0,0,0,0.4);
}
.prim-btn:active { transform: translateY(0); }
.prim-ico { font-size: 18px; line-height: 1; }

.panel-div { height: 1px; background: var(--glass-border); margin: 2px 8px 6px; }

/* SCENE TREE */
#tree-wrap { flex: 1; overflow-y: auto; padding: 0 4px 4px; }
#tree-wrap::-webkit-scrollbar { width: 3px; }
#tree-wrap::-webkit-scrollbar-thumb { background: var(--ink-ghost); border-radius: 2px; }

.tree-node {
  padding: 5px 8px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  color: var(--ink-mid);
  border-radius: var(--r-sm);
  transition: all 0.1s;
  position: relative;
}
.tree-node:hover { background: var(--glass-bg); color: var(--ink); }
.tree-node.sel {
  background: var(--cyan-dim);
  color: var(--cyan);
  border: 1px solid rgba(0,212,255,0.2);
}
.tree-node .tn-ico { font-size: 10px; opacity: 0.6; }
.tree-node .tn-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.tree-node .tn-eye {
  opacity: 0;
  width: 14px;
  font-size: 10px;
  transition: opacity 0.1s;
}
.tree-node:hover .tn-eye { opacity: 1; }
.tree-node.hidden-obj { opacity: 0.35; }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   VIEWPORT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#vp {
  position: relative;
  overflow: hidden;
  background: var(--void);
}

#c3d { display: block; width: 100%; height: 100%; }

/* Viewport UI elements */
.vp-overlay { position: absolute; inset: 0; pointer-events: none; }

.vp-corner-tl {
  position: absolute;
  top: 14px; left: 14px;
  font-size: 10px;
  color: var(--ink-dim);
}

.vp-cam-label {
  position: absolute;
  top: 14px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(5,5,8,0.7);
  backdrop-filter: var(--blur-sm);
  border: 1px solid var(--glass-border);
  border-radius: 20px;
  padding: 4px 14px;
  font-size: 10px;
  color: var(--ink-mid);
  pointer-events: none;
  white-space: nowrap;
}

/* TRANSFORM MODE TOOLBAR - floating in viewport */
#tm-bar {
  position: absolute;
  top: 14px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 2px;
  background: rgba(5,5,8,0.82);
  backdrop-filter: var(--blur-sm);
  border: 1px solid var(--glass-border);
  border-radius: 30px;
  padding: 4px;
  pointer-events: all;
  z-index: 10;
}
.tm-btn {
  width: 34px; height: 26px;
  background: transparent;
  border: 1px solid transparent;
  border-radius: 20px;
  color: var(--ink-mid);
  cursor: pointer;
  display: flex; align-items: center; justify-content: center;
  font-size: 12px;
  transition: all 0.15s;
  font-family: 'Fira Code', monospace;
  font-size: 10px;
  gap: 3px;
}
.tm-btn:hover { background: var(--glass-bg); color: var(--ink); }
.tm-btn.active { background: var(--cyan-dim); color: var(--cyan); border-color: rgba(0,212,255,0.3); }

/* Empty hint */
#empty-hint {
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
  pointer-events: none;
  color: var(--ink-dim);
  font-size: 11px;
  line-height: 2.2;
}
.eh-icon { font-size: 40px; margin-bottom: 8px; opacity: 0.2; }
.eh-key { color: var(--cyan); opacity: 0.7; }

/* GIZMO */
#gizmo-cnv {
  position: absolute;
  bottom: 16px; right: 16px;
  width: 72px; height: 72px;
  pointer-events: none;
}

/* Stats */
#vp-stats {
  position: absolute;
  bottom: 14px;
  left: 14px;
  font-size: 10px;
  color: var(--ink-dim);
  pointer-events: none;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   RIGHT PANEL
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#right {
  background: rgba(5,5,8,0.7);
  backdrop-filter: var(--blur);
  border-left: 1px solid var(--glass-border);
  display: flex;
  flex-direction: column;
  overflow-y: auto;
}
#right::-webkit-scrollbar { width: 3px; }
#right::-webkit-scrollbar-thumb { background: var(--ink-ghost); border-radius: 2px; }

/* No selection */
#no-sel {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: var(--ink-dim);
  font-size: 11px;
  text-align: center;
  gap: 8px;
  padding: 20px;
}
.nosel-ico { font-size: 32px; opacity: 0.15; }

/* Props */
.prop-sec { border-bottom: 1px solid var(--glass-border); }
.sec-head {
  padding: 8px 12px;
  font-family: 'Syne', sans-serif;
  font-size: 9px;
  font-weight: 700;
  letter-spacing: 0.18em;
  text-transform: uppercase;
  color: var(--ink-dim);
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: color 0.1s;
}
.sec-head:hover { color: var(--ink-mid); }
.sec-head .chev { transition: transform 0.2s; font-style: normal; }
.sec-head.coll .chev { transform: rotate(-90deg); }
.sec-body { padding: 4px 10px 10px; }

/* Vec3 row */
.plabel {
  font-size: 9px;
  color: var(--ink-dim);
  letter-spacing: 0.1em;
  text-transform: uppercase;
  margin-bottom: 4px;
  margin-top: 4px;
}
.v3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 3px; margin-bottom: 4px; }
.vf { display: flex; flex-direction: column; gap: 2px; }
.vf label { font-size: 9px; padding-left: 3px; letter-spacing: 0.05em; }
.vf label.lx { color: var(--ax); }
.vf label.ly { color: var(--ay); }
.vf label.lz { color: var(--az); }
.ni {
  background: rgba(255,255,255,0.04);
  border: 1px solid var(--glass-border);
  border-radius: var(--r-sm);
  color: var(--ink);
  font-family: 'Fira Code', monospace;
  font-size: 10px;
  padding: 4px 5px;
  width: 100%;
  text-align: center;
  transition: border-color 0.15s, background 0.15s;
  outline: none;
}
.ni:hover { border-color: var(--glass-border-active); }
.ni:focus { border-color: rgba(0,212,255,0.5); background: rgba(0,212,255,0.04); }

/* Color */
.cr { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
.ci {
  width: 30px; height: 22px;
  border: 1px solid var(--glass-border);
  border-radius: var(--r-sm);
  padding: 2px;
  background: transparent;
  cursor: pointer;
}
.cl { color: var(--ink-mid); font-size: 11px; }

/* Range */
.rr { display: flex; align-items: center; gap: 8px; margin-bottom: 5px; }
.rr label { color: var(--ink-mid); font-size: 10px; min-width: 58px; }
.ri { flex: 1; accent-color: var(--cyan); cursor: pointer; height: 3px; }
.rv { color: var(--ink-mid); font-size: 10px; min-width: 28px; text-align: right; }

/* Toggle */
.tr { display: flex; align-items: center; justify-content: space-between; margin-bottom: 5px; }
.tr label { color: var(--ink-mid); font-size: 11px; }
.tog {
  width: 28px; height: 14px;
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  border-radius: 10px;
  cursor: pointer;
  position: relative;
  transition: all 0.2s;
}
.tog.on { background: rgba(0,212,255,0.25); border-color: rgba(0,212,255,0.5); }
.tog::after {
  content: '';
  position: absolute;
  width: 10px; height: 10px;
  background: var(--ink-dim);
  border-radius: 50%;
  top: 1px; left: 1px;
  transition: transform 0.2s, background 0.2s;
}
.tog.on::after { transform: translateX(14px); background: var(--cyan); }

/* Boolean ops */
.bool-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 4px; }
.bool-btn {
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  border-radius: var(--r-sm);
  padding: 8px 2px;
  cursor: pointer;
  color: var(--ink-mid);
  font-family: 'Fira Code', monospace;
  font-size: 9px;
  text-align: center;
  display: flex; flex-direction: column; align-items: center; gap: 4px;
  transition: all 0.2s;
}
.bool-btn:hover { background: var(--glass-bg-hover); border-color: var(--glass-border-active); color: var(--ink); transform: translateY(-1px); }
.bool-btn .bi { font-size: 18px; }
.bool-hint { font-size: 9px; color: var(--ink-dim); margin-bottom: 6px; line-height: 1.5; }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   STATUS BAR
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#statusbar {
  grid-column: 1 / -1;
  background: rgba(5,5,8,0.9);
  border-top: 1px solid var(--glass-border);
  display: flex;
  align-items: center;
  padding: 0 12px;
  gap: 14px;
  font-size: 10px;
  color: var(--ink-dim);
}
.si { display: flex; gap: 4px; }
.si span { color: var(--ink-mid); }
.ss { color: var(--glass-border); }
.kbd {
  display: inline-block;
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  border-radius: 3px;
  padding: 0 4px;
  font-size: 9px;
  color: var(--ink-dim);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MODALS & TOASTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.modal-bg {
  position: fixed; inset: 0;
  background: rgba(0,0,0,0.6);
  backdrop-filter: var(--blur-sm);
  z-index: 2000;
  display: flex; align-items: center; justify-content: center;
}
.modal-box {
  background: rgba(8,8,14,0.95);
  border: 1px solid var(--glass-border-active);
  border-radius: 14px;
  padding: 24px;
  min-width: 340px;
  box-shadow: 0 24px 80px rgba(0,0,0,0.9);
  animation: dropIn 0.2s ease;
}
.modal-box h3 { font-family: 'Syne', sans-serif; font-size: 14px; font-weight: 700; color: var(--ink); margin-bottom: 10px; }
.modal-box p { color: var(--ink-mid); font-size: 11px; line-height: 1.7; margin-bottom: 16px; }
.modal-btns { display: flex; gap: 8px; justify-content: flex-end; }
.mbtn {
  padding: 7px 18px;
  border-radius: var(--r-sm);
  border: 1px solid var(--glass-border);
  background: var(--glass-bg);
  color: var(--ink-mid);
  cursor: pointer;
  font-family: 'Fira Code', monospace;
  font-size: 11px;
  transition: all 0.15s;
}
.mbtn:hover { background: var(--glass-bg-hover); color: var(--ink); border-color: var(--glass-border-active); }
.mbtn.primary { background: var(--cyan-dim); border-color: rgba(0,212,255,0.4); color: var(--cyan); }
.mbtn.primary:hover { background: rgba(0,212,255,0.25); }

#toast {
  position: fixed;
  bottom: 36px; left: 50%;
  transform: translateX(-50%);
  background: rgba(8,8,14,0.92);
  backdrop-filter: var(--blur-sm);
  border: 1px solid var(--glass-border-active);
  border-radius: 30px;
  padding: 7px 20px;
  font-size: 11px;
  color: var(--ink);
  z-index: 5000;
  box-shadow: 0 8px 32px rgba(0,0,0,0.6);
  transition: opacity 0.4s;
  pointer-events: none;
  white-space: nowrap;
}

/* Context menu */
.ctx {
  position: fixed;
  background: rgba(8,8,14,0.95);
  backdrop-filter: var(--blur);
  border: 1px solid var(--glass-border-active);
  border-radius: var(--r);
  padding: 5px;
  z-index: 3000;
  min-width: 170px;
  box-shadow: 0 16px 48px rgba(0,0,0,0.8);
  animation: dropIn 0.12s ease;
}
.ctx-it {
  padding: 6px 10px;
  cursor: pointer;
  border-radius: var(--r-sm);
  color: var(--ink-mid);
  font-size: 11px;
  display: flex; justify-content: space-between; align-items: center;
  transition: background 0.1s;
}
.ctx-it:hover { background: var(--glass-bg-hover); color: var(--ink); }
.ctx-it.danger { color: var(--red); }
.ctx-it.danger:hover { background: rgba(255,68,102,0.1); }
.ctx-sep { height: 1px; background: var(--glass-border); margin: 3px 0; }

/* scrollbar global */
::-webkit-scrollbar { width: 4px; height: 4px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--ink-ghost); border-radius: 2px; }

input[type=file] { display: none; }
</style>
</head>
<body>
<div id="app">

<!-- â•â•â• TOPBAR â•â•â• -->
<div id="topbar">
  <div class="logo">
    <div class="logo-mark">R</div>
    REN3D
  </div>

  <div class="menu-wrap">
    <button class="menu-trigger" onclick="openMenu('file',this)">Ğ¤Ğ°Ğ¹Ğ»</button>
    <div class="dropdown" id="dd-file">
      <div class="dd-item" onclick="newScene()">ĞĞ¾Ğ²Ğ°Ñ ÑÑ†ĞµĞ½Ğ° <span class="ks">Ctrl+N</span></div>
      <div class="dd-sep"></div>
      <div class="dd-item" onclick="doImport()">Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚ .stl/.obj <span class="ks">Ctrl+I</span></div>
      <div class="dd-sep"></div>
      <div class="dd-item" onclick="exportSTL()">Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ .stl <span class="ks">Ctrl+E</span></div>
      <div class="dd-item" onclick="exportOBJ()">Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ .obj</div>
    </div>
  </div>

  <div class="menu-wrap">
    <button class="menu-trigger" onclick="openMenu('edit',this)">ĞŸÑ€Ğ°Ğ²ĞºĞ°</button>
    <div class="dropdown" id="dd-edit">
      <div class="dd-item" onclick="undo()">ĞÑ‚Ğ¼ĞµĞ½Ğ° <span class="ks">Ctrl+Z</span></div>
      <div class="dd-item" onclick="redo()">ĞŸĞ¾Ğ²Ñ‚Ğ¾Ñ€ <span class="ks">Ctrl+Y</span></div>
      <div class="dd-sep"></div>
      <div class="dd-item" onclick="duplicateSel()">Ğ”ÑƒĞ±Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ <span class="ks">Ctrl+D</span></div>
      <div class="dd-item" onclick="deleteSel()">Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ <span class="ks">Del</span></div>
      <div class="dd-sep"></div>
      <div class="dd-item" onclick="selectAll()">Ğ’Ñ‹Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒ Ğ²ÑÑ‘ <span class="ks">Ctrl+A</span></div>
      <div class="dd-item" onclick="deselectAll()">Ğ¡Ğ½ÑÑ‚ÑŒ Ğ²Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ <span class="ks">Esc</span></div>
    </div>
  </div>

  <div class="menu-wrap">
    <button class="menu-trigger" onclick="openMenu('view',this)">Ğ’Ğ¸Ğ´</button>
    <div class="dropdown" id="dd-view">
      <div class="dd-item" onclick="camView('persp')">ĞŸĞµÑ€ÑĞ¿ĞµĞºÑ‚Ğ¸Ğ²Ğ° <span class="ks">Num 5</span></div>
      <div class="dd-item" onclick="camView('front')">Ğ¡Ğ¿ĞµÑ€ĞµĞ´Ğ¸ <span class="ks">Num 1</span></div>
      <div class="dd-item" onclick="camView('top')">Ğ¡Ğ²ĞµÑ€Ñ…Ñƒ <span class="ks">Num 7</span></div>
      <div class="dd-item" onclick="camView('right')">Ğ¡Ğ¿Ñ€Ğ°Ğ²Ğ° <span class="ks">Num 3</span></div>
      <div class="dd-sep"></div>
      <div class="dd-item" onclick="frameAll()">ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ²ÑÑ‘ <span class="ks">Home</span></div>
      <div class="dd-item" onclick="frameSel()">ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ½Ğ¾Ğµ <span class="ks">F</span></div>
      <div class="dd-sep"></div>
      <div class="dd-item" onclick="toggleGrid()">Ğ¡ĞµÑ‚ĞºĞ° <span class="ks">G</span></div>
      <div class="dd-item" onclick="toggleWire()">ĞšĞ°Ñ€ĞºĞ°Ñ <span class="ks">Z</span></div>
    </div>
  </div>

  <div class="menu-wrap">
    <button class="menu-trigger" onclick="openMenu('add',this)">Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ</button>
    <div class="dropdown" id="dd-add">
      <div class="dd-item" onclick="addObj('box')">â¬› ĞšÑƒĞ± <span class="ks">Shift+C</span></div>
      <div class="dd-item" onclick="addObj('sphere')">ğŸ”µ Ğ¡Ñ„ĞµÑ€Ğ° <span class="ks">Shift+S</span></div>
      <div class="dd-item" onclick="addObj('cyl')">ğŸ”· Ğ¦Ğ¸Ğ»Ğ¸Ğ½Ğ´Ñ€ <span class="ks">Shift+Y</span></div>
      <div class="dd-item" onclick="addObj('cone')">ğŸ”º ĞšĞ¾Ğ½ÑƒÑ <span class="ks">Shift+O</span></div>
      <div class="dd-item" onclick="addObj('torus')">â­• Ğ¢Ğ¾Ñ€ <span class="ks">Shift+T</span></div>
      <div class="dd-item" onclick="addObj('plane')">â¬œ ĞŸĞ»Ğ¾ÑĞºĞ¾ÑÑ‚ÑŒ <span class="ks">Shift+P</span></div>
    </div>
  </div>

  <div class="tb-sep"></div>

  <div class="tb-group">
    <button class="tb-btn active" id="tbb-sel" title="Ğ’Ñ‹Ğ±Ğ¾Ñ€ (Q)" onclick="setTool('sel')">âœ¦</button>
    <button class="tb-btn" id="tbb-move" title="ĞŸĞµÑ€ĞµĞ¼ĞµÑ‰ĞµĞ½Ğ¸Ğµ (G)" onclick="setTool('move')">âœ¥</button>
    <button class="tb-btn" id="tbb-rot" title="Ğ’Ñ€Ğ°Ñ‰ĞµĞ½Ğ¸Ğµ (R)" onclick="setTool('rot')">â†»</button>
    <button class="tb-btn" id="tbb-scale" title="ĞœĞ°ÑÑˆÑ‚Ğ°Ğ± (S)" onclick="setTool('scale')">âŠ</button>
  </div>

  <div class="tb-sep"></div>

  <div class="tb-group">
    <button class="tb-btn" title="ĞĞ¾Ğ²Ğ°Ñ ÑÑ†ĞµĞ½Ğ°" onclick="newScene()">ğŸ—‹</button>
    <button class="tb-btn" title="Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚ (Ctrl+I)" onclick="doImport()">â‡ª</button>
    <button class="tb-btn" title="Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ STL (Ctrl+E)" onclick="exportSTL()">â‡©</button>
  </div>

  <div class="spacer"></div>
  <div style="font-size:10px;color:var(--ink-dim)">Ğ ĞµĞ¶Ğ¸Ğ¼: <span id="mode-lbl" style="color:var(--cyan)">ĞĞ±ÑŠĞµĞºÑ‚</span></div>
</div>

<!-- â•â•â• LEFT PANEL â•â•â• -->
<div id="left">
  <div class="panel-title">ĞŸÑ€Ğ¸Ğ¼Ğ¸Ñ‚Ğ¸Ğ²Ñ‹</div>
  <div class="prim-grid">
    <button class="prim-btn" onclick="addObj('box')"><span class="prim-ico">â¬›</span>ĞšÑƒĞ±</button>
    <button class="prim-btn" onclick="addObj('sphere')"><span class="prim-ico">ğŸ”µ</span>Ğ¡Ñ„ĞµÑ€Ğ°</button>
    <button class="prim-btn" onclick="addObj('cyl')"><span class="prim-ico">ğŸ”·</span>Ğ¦Ğ¸Ğ»Ğ¸Ğ½Ğ´Ñ€</button>
    <button class="prim-btn" onclick="addObj('cone')"><span class="prim-ico">ğŸ”º</span>ĞšĞ¾Ğ½ÑƒÑ</button>
    <button class="prim-btn" onclick="addObj('torus')"><span class="prim-ico">â­•</span>Ğ¢Ğ¾Ñ€</button>
    <button class="prim-btn" onclick="addObj('plane')"><span class="prim-ico">â¬œ</span>ĞŸĞ»Ğ¾ÑĞºĞ¾ÑÑ‚ÑŒ</button>
  </div>
  <div class="panel-div"></div>
  <div class="panel-title">
    Ğ¡Ñ†ĞµĞ½Ğ°
    <span id="obj-cnt" style="font-family:'Fira Code';font-size:9px;font-weight:400;letter-spacing:0;text-transform:none">0</span>
  </div>
  <div id="tree-wrap"></div>
</div>

<!-- â•â•â• VIEWPORT â•â•â• -->
<div id="vp">
  <canvas id="c3d"></canvas>

  <div id="tm-bar">
    <button class="tm-btn active" id="tmb-none" onclick="setGizmoMode('none')" title="Ğ’Ñ‹Ğ±Ğ¾Ñ€ (Q)">âœ¦ Ğ’Ñ‹Ğ±Ğ¾Ñ€</button>
    <button class="tm-btn" id="tmb-translate" onclick="setGizmoMode('translate')" title="ĞŸĞµÑ€ĞµĞ¼ĞµÑ‰ĞµĞ½Ğ¸Ğµ (G)">âœ¥ Move</button>
    <button class="tm-btn" id="tmb-rotate" onclick="setGizmoMode('rotate')" title="Ğ’Ñ€Ğ°Ñ‰ĞµĞ½Ğ¸Ğµ (R)">â†» Rot</button>
    <button class="tm-btn" id="tmb-scale" onclick="setGizmoMode('scale')" title="ĞœĞ°ÑÑˆÑ‚Ğ°Ğ± (S)">âŠ Scale</button>
  </div>

  <div id="empty-hint">
    <div class="eh-icon">â—ˆ</div>
    Ğ¡Ñ†ĞµĞ½Ğ° Ğ¿ÑƒÑÑ‚Ğ°<br>
    <span class="eh-key">Shift+C</span> â€” ĞšÑƒĞ± &nbsp;
    <span class="eh-key">Shift+S</span> â€” Ğ¡Ñ„ĞµÑ€Ğ°<br>
    <span class="eh-key">Ctrl+I</span> â€” Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚ &nbsp;
    <span class="eh-key">ĞŸĞšĞœ</span> â€” ĞÑ€Ğ±Ğ¸Ñ‚Ğ°
  </div>

  <canvas id="gizmo-cnv" width="72" height="72"></canvas>
  <div id="vp-stats">ĞĞ±ÑŠĞµĞºÑ‚Ğ¾Ğ²: 0 | Ğ¢Ñ€Ğ¸Ñ: 0</div>
</div>

<!-- â•â•â• RIGHT PANEL â•â•â• -->
<div id="right">
  <div id="no-sel">
    <div class="nosel-ico">â—ˆ</div>
    <span style="color:var(--ink-dim)">ĞĞ¸Ñ‡ĞµĞ³Ğ¾ Ğ½Ğµ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ¾</span>
    <span style="color:var(--ink-ghost);font-size:10px">ĞšĞ»Ğ¸ĞºĞ½Ğ¸Ñ‚Ğµ Ğ½Ğ° Ğ¾Ğ±ÑŠĞµĞºÑ‚</span>
  </div>

  <div id="props" style="display:none">

    <!-- Transform -->
    <div class="prop-sec">
      <div class="sec-head" onclick="toggleSec(this)">Ğ¢Ñ€Ğ°Ğ½ÑÑ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ <i class="chev">â–¾</i></div>
      <div class="sec-body">
        <div class="plabel">ĞŸĞ¾Ğ·Ğ¸Ñ†Ğ¸Ñ</div>
        <div class="v3">
          <div class="vf"><label class="lx">X</label><input class="ni" id="px" type="number" step="0.1" onchange="applyTf()"></div>
          <div class="vf"><label class="ly">Y</label><input class="ni" id="py" type="number" step="0.1" onchange="applyTf()"></div>
          <div class="vf"><label class="lz">Z</label><input class="ni" id="pz" type="number" step="0.1" onchange="applyTf()"></div>
        </div>
        <div class="plabel">Ğ’Ñ€Ğ°Ñ‰ĞµĞ½Ğ¸Ğµ Â°</div>
        <div class="v3">
          <div class="vf"><label class="lx">X</label><input class="ni" id="rx" type="number" step="1" onchange="applyTf()"></div>
          <div class="vf"><label class="ly">Y</label><input class="ni" id="ry" type="number" step="1" onchange="applyTf()"></div>
          <div class="vf"><label class="lz">Z</label><input class="ni" id="rz" type="number" step="1" onchange="applyTf()"></div>
        </div>
        <div class="plabel">ĞœĞ°ÑÑˆÑ‚Ğ°Ğ±</div>
        <div class="v3">
          <div class="vf"><label class="lx">X</label><input class="ni" id="sx" type="number" step="0.1" onchange="applyTf()"></div>
          <div class="vf"><label class="ly">Y</label><input class="ni" id="sy" type="number" step="0.1" onchange="applyTf()"></div>
          <div class="vf"><label class="lz">Z</label><input class="ni" id="sz" type="number" step="0.1" onchange="applyTf()"></div>
        </div>
      </div>
    </div>

    <!-- Material -->
    <div class="prop-sec">
      <div class="sec-head" onclick="toggleSec(this)">ĞœĞ°Ñ‚ĞµÑ€Ğ¸Ğ°Ğ» <i class="chev">â–¾</i></div>
      <div class="sec-body">
        <div class="cr">
          <input type="color" class="ci" id="mc" value="#00d4ff" onchange="applyMat()">
          <span class="cl">Ğ¦Ğ²ĞµÑ‚ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ°</span>
        </div>
        <div class="rr"><label>ĞœĞµÑ‚Ğ°Ğ»Ğ»Ğ¸Ğº</label><input type="range" class="ri" id="mm" min="0" max="1" step="0.01" value="0" oninput="rng(this,'mmv');applyMat()"><span class="rv" id="mmv">0</span></div>
        <div class="rr"><label>Ğ¨ĞµÑ€Ğ¾Ñ…Ğ¾Ğ².</label><input type="range" class="ri" id="mr" min="0" max="1" step="0.01" value="0.5" oninput="rng(this,'mrv');applyMat()"><span class="rv" id="mrv">0.5</span></div>
        <div class="rr"><label>ĞŸÑ€Ğ¾Ğ·Ñ€Ğ°Ñ‡Ğ½.</label><input type="range" class="ri" id="mo" min="0" max="1" step="0.01" value="1" oninput="rng(this,'mov');applyMat()"><span class="rv" id="mov">1</span></div>
        <div class="tr"><label>ĞšĞ°Ñ€ĞºĞ°Ñ</label><div class="tog" id="tog-wire" onclick="toggleWireObj()"></div></div>
      </div>
    </div>

    <!-- Boolean -->
    <div class="prop-sec">
      <div class="sec-head" onclick="toggleSec(this)">Ğ‘ÑƒĞ»ĞµĞ²Ñ‹ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ <i class="chev">â–¾</i></div>
      <div class="sec-body">
        <div class="bool-hint">Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ 2 Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ° (Shift+ĞºĞ»Ğ¸Ğº), Ğ·Ğ°Ñ‚ĞµĞ¼ Ğ²Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ:</div>
        <div class="bool-grid">
          <button class="bool-btn" onclick="boolOp('union')"><span class="bi">âŠ•</span>ĞĞ±ÑŠĞµĞ´.</button>
          <button class="bool-btn" onclick="boolOp('subtract')"><span class="bi">âŠ–</span>Ğ’Ñ‹Ñ‡Ğ¸Ñ‚.</button>
          <button class="bool-btn" onclick="boolOp('intersect')"><span class="bi">âŠ—</span>ĞŸĞµÑ€ĞµÑĞµÑ‡.</button>
        </div>
      </div>
    </div>

    <!-- Geom params -->
    <div class="prop-sec">
      <div class="sec-head" onclick="toggleSec(this)">Ğ“ĞµĞ¾Ğ¼ĞµÑ‚Ñ€Ğ¸Ñ <i class="chev">â–¾</i></div>
      <div class="sec-body" id="geom-body"></div>
    </div>

  </div>
</div>

<!-- â•â•â• STATUSBAR â•â•â• -->
<div id="statusbar">
  <div class="si">Ren3D <span>v2.0</span></div>
  <div class="ss">|</div>
  <div class="si">Ğ’Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ¾: <span id="sel-cnt">0</span></div>
  <div class="spacer"></div>
  <div style="display:flex;gap:6px;align-items:center">
    <span class="kbd">ĞŸĞšĞœ</span>ĞÑ€Ğ±Ğ¸Ñ‚Ğ°
    <span class="kbd">Ğ¡ĞšĞœ</span>ĞŸĞ°Ğ½
    <span class="kbd">ĞšĞ¾Ğ»ĞµÑĞ¾</span>Ğ—ÑƒĞ¼
    <span class="kbd">F</span>Ğ¤Ğ¾ĞºÑƒÑ
    <span class="kbd">Del</span>Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ
    <span class="kbd">Ctrl+D</span>Ğ”ÑƒĞ±Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ
    <span class="kbd">Z</span>ĞšĞ°Ñ€ĞºĞ°Ñ
  </div>
</div>
</div>

<input type="file" id="file-in" accept=".stl,.obj" onchange="handleFile(event)">
<div id="toast" style="opacity:0"></div>

<!-- THREE.JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  REN3D v2 â€” Core Engine
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
'use strict';

// â”€â”€ State â”€â”€
let scene, camera, renderer, raycaster;
const orbit = { theta: 0.7, phi: 1.1, radius: 10, target: new THREE.Vector3() };
let mb = -1, drag = false, lm = {x:0,y:0}, mouse = new THREE.Vector2();

let objs = [];       // scene objects
let sel = [];        // selected
let counter = {};
let gridOn = true, wireOn = false;
let activeTool = 'sel';
let gizmoMode = 'none';
let gridMesh;

// Transform gizmo state
let gizmo = null;
let gizmoActive = false, gizmoAxis = null;

// Undo
let undoStack = [], redoStack = [];

// Colors
const PALETTE = ['#00d4ff','#ff6b35','#39ff8f','#b78bff','#ffe066','#ff4466','#4499ff','#ffaa44'];
let ci = 0;

// â”€â”€ Init â”€â”€
function init() {
  const canvas = document.getElementById('c3d');
  const vp = document.getElementById('vp');

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x050508);

  renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  resize();

  camera = new THREE.PerspectiveCamera(55, 1, 0.01, 1000);
  updateCam();

  raycaster = new THREE.Raycaster();

  // Lights
  scene.add(new THREE.AmbientLight(0xffffff, 0.35));
  const key = new THREE.DirectionalLight(0xffffff, 0.9);
  key.position.set(6, 10, 6); key.castShadow = true;
  key.shadow.mapSize.set(2048, 2048);
  scene.add(key);
  const fill = new THREE.DirectionalLight(0x4488ff, 0.25);
  fill.position.set(-6, 2, -4); scene.add(fill);
  const rim = new THREE.DirectionalLight(0x00d4ff, 0.15);
  rim.position.set(0, -4, 6); scene.add(rim);

  // Grid
  buildGrid();

  // Events
  canvas.addEventListener('mousedown', onMD);
  canvas.addEventListener('mousemove', onMM);
  canvas.addEventListener('mouseup', onMU);
  canvas.addEventListener('wheel', onWheel, {passive:false});
  canvas.addEventListener('contextmenu', onCtx);
  window.addEventListener('keydown', onKey);
  window.addEventListener('resize', resize);
  document.addEventListener('click', closeMenus);

  animate();
  updateStats();
}

function buildGrid() {
  if (gridMesh) scene.remove(gridMesh);
  gridMesh = new THREE.GridHelper(24, 24, 0x1a1a2e, 0x111120);
  scene.add(gridMesh);
}

function resize() {
  const vp = document.getElementById('vp');
  const w = vp.clientWidth, h = vp.clientHeight;
  renderer.setSize(w, h);
  if (camera) { camera.aspect = w/h; camera.updateProjectionMatrix(); }
}

function animate() {
  requestAnimationFrame(animate);
  updateGizmoMeshPosition();
  renderer.render(scene, camera);
  drawOriGizmo();
}

// â”€â”€ Camera â”€â”€
function updateCam() {
  const { theta, phi, radius, target } = orbit;
  camera.position.set(
    target.x + radius * Math.sin(phi) * Math.sin(theta),
    target.y + radius * Math.cos(phi),
    target.z + radius * Math.sin(phi) * Math.cos(theta)
  );
  camera.lookAt(target);
}

function camView(v) {
  if (v==='persp') { orbit.theta=0.7; orbit.phi=1.1; }
  else if (v==='front') { orbit.theta=0; orbit.phi=Math.PI/2; }
  else if (v==='top') { orbit.theta=0; orbit.phi=0.02; }
  else if (v==='right') { orbit.theta=Math.PI/2; orbit.phi=Math.PI/2; }
  updateCam(); closeAllMenus();
}

// â”€â”€ Mouse â”€â”€
function onMD(e) {
  e.preventDefault();
  drag = false; mb = e.button; lm = {x:e.clientX,y:e.clientY};
  updateMouse(e);

  if (mb === 0 && gizmoMode !== 'none' && sel.length > 0) {
    const hit = hitTestGizmo();
    if (hit) {
      gizmoActive = true;
      gizmoAxis   = hit;
      return;
    }
  }
}

function onMM(e) {
  const dx = e.clientX - lm.x, dy = e.clientY - lm.y;
  if (Math.abs(dx)>1.5||Math.abs(dy)>1.5) drag = true;
  updateMouse(e);

  if (gizmoActive && mb===0) {
    applyGizmoTransform(e, dx, dy);
    lm = {x:e.clientX,y:e.clientY};
    return;
  }

  if (mb === 2 || mb === 1) { // Orbit
    orbit.theta -= dx * 0.005;
    orbit.phi = Math.max(0.04, Math.min(Math.PI-0.04, orbit.phi - dy*0.005));
    updateCam();
  }
  lm = {x:e.clientX,y:e.clientY};
}

function onMU(e) {
  if (gizmoActive) {
    gizmoActive = false;
    if (sel.length>0) saveUndo();
    updatePropsPanel();
    mb = -1; return;
  }
  if (!drag && mb===0) handleClick(e);
  mb = -1; drag = false;
}

function onWheel(e) {
  e.preventDefault();
  orbit.radius = Math.max(0.3, Math.min(200, orbit.radius * (1 + e.deltaY*0.001)));
  updateCam();
}

function updateMouse(e) {
  const vp = document.getElementById('vp');
  const r = vp.getBoundingClientRect();
  mouse.set(((e.clientX-r.left)/r.width)*2-1, -((e.clientY-r.top)/r.height)*2+1);
}

// RMB PAN
document.getElementById('c3d').addEventListener('mousedown', e => { if(e.button===2) mb=2; });
document.addEventListener('mousemove', e => {
  if (mb===2 && drag) {
    const dx=e.clientX-lm.x, dy=e.clientY-lm.y;
    const right=new THREE.Vector3().crossVectors(camera.getWorldDirection(new THREE.Vector3()),camera.up).normalize();
    const up=new THREE.Vector3(0,1,0);
    const sp=orbit.radius*0.003;
    orbit.target.addScaledVector(right,-dx*sp);
    orbit.target.addScaledVector(up,dy*sp);
    updateCam(); lm={x:e.clientX,y:e.clientY};
  }
});

// â”€â”€ Click / Selection â”€â”€
function handleClick(e) {
  raycaster.setFromCamera(mouse, camera);
  const meshes = objs.map(o=>o.mesh);
  const hits = raycaster.intersectObjects(meshes);

  if (hits.length) {
    const obj = objs.find(o=>o.mesh===hits[0].object);
    if (obj) {
      if (e.shiftKey) toggleSel(obj);
      else selectObj(obj, true);
    }
  } else {
    if (!e.shiftKey) deselectAll();
  }
}

function selectObj(obj, excl=false) {
  if (excl) deselectAll(false);
  if (!sel.includes(obj)) {
    sel.push(obj);
    obj.mesh.material.emissive = new THREE.Color(0x00d4ff);
    obj.mesh.material.emissiveIntensity = 0.12;
  }
  updateSelUI(); showGizmoMesh();
}

function toggleSel(obj) {
  const i = sel.indexOf(obj);
  if (i>=0) { sel.splice(i,1); obj.mesh.material.emissive=new THREE.Color(0); obj.mesh.material.emissiveIntensity=0; }
  else { sel.push(obj); obj.mesh.material.emissive=new THREE.Color(0x00d4ff); obj.mesh.material.emissiveIntensity=0.12; }
  updateSelUI(); showGizmoMesh();
}

function deselectAll(upd=true) {
  sel.forEach(o=>{ if(o&&o.mesh&&o.mesh.material){ o.mesh.material.emissive=new THREE.Color(0); o.mesh.material.emissiveIntensity=0; } });
  sel=[];
  hideGizmoMesh();
  if(upd) updateSelUI();
}

function selectAll() {
  deselectAll(false);
  objs.forEach(o=>{ sel.push(o); o.mesh.material.emissive=new THREE.Color(0x00d4ff); o.mesh.material.emissiveIntensity=0.12; });
  updateSelUI(); showGizmoMesh();
}

function updateSelUI() {
  document.querySelectorAll('.tree-node').forEach(el => {
    const id = +el.dataset.id;
    el.classList.toggle('sel', sel.some(o=>o.id===id));
  });
  document.getElementById('sel-cnt').textContent = sel.length;

  const noSel = document.getElementById('no-sel');
  const props = document.getElementById('props');
  if (sel.length===1) {
    noSel.style.display='none'; props.style.display='block';
    updatePropsPanel();
  } else {
    noSel.style.display='flex'; props.style.display='none';
    if (sel.length===0) {
      noSel.innerHTML='<div class="nosel-ico">â—ˆ</div><span style="color:var(--ink-dim)">ĞĞ¸Ñ‡ĞµĞ³Ğ¾ Ğ½Ğµ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ¾</span><span style="color:var(--ink-ghost);font-size:10px">ĞšĞ»Ğ¸ĞºĞ½Ğ¸Ñ‚Ğµ Ğ½Ğ° Ğ¾Ğ±ÑŠĞµĞºÑ‚</span>';
    } else {
      noSel.innerHTML=`<div class="nosel-ico">â—ˆ</div><span style="color:var(--ink-dim)">Ğ’Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ¾: ${sel.length}</span><span style="color:var(--ink-ghost);font-size:10px">Ğ”Ğ»Ñ ÑĞ²Ğ¾Ğ¹ÑÑ‚Ğ² Ğ²Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ 1</span>`;
    }
  }
}

// â”€â”€ Props Panel â”€â”€
function updatePropsPanel() {
  if (sel.length!==1) return;
  const obj=sel[0], m=obj.mesh;
  const deg = THREE.MathUtils.radToDeg;

  const set = (id,v) => { const el=document.getElementById(id); if(el) el.value=typeof v==='number'?+v.toFixed(4):v; };
  set('px',m.position.x); set('py',m.position.y); set('pz',m.position.z);
  set('rx',deg(m.rotation.x)); set('ry',deg(m.rotation.y)); set('rz',deg(m.rotation.z));
  set('sx',m.scale.x); set('sy',m.scale.y); set('sz',m.scale.z);
  set('mc','#'+m.material.color.getHexString());
  set('mm',m.material.metalness||0);
  set('mr',m.material.roughness!==undefined?m.material.roughness:0.5);
  set('mo',m.material.opacity!==undefined?m.material.opacity:1);
  document.getElementById('mmv').textContent=(+document.getElementById('mm').value).toFixed(2);
  document.getElementById('mrv').textContent=(+document.getElementById('mr').value).toFixed(2);
  document.getElementById('mov').textContent=(+document.getElementById('mo').value).toFixed(2);
  document.getElementById('tog-wire').classList.toggle('on', m.material.wireframe||false);
  buildGeomProps(obj);
}

function buildGeomProps(obj) {
  const el=document.getElementById('geom-body');
  const p=obj.params||{};
  let h='';
  if (obj.type==='box') {
    h=`<div class="plabel">Ğ Ğ°Ğ·Ğ¼ĞµÑ€</div><div class="v3">
      <div class="vf"><label>Ğ¨</label><input class="ni" id="gw" type="number" step="0.1" value="${p.w||1}" onchange="rebuildGeom()"></div>
      <div class="vf"><label>Ğ’</label><input class="ni" id="gh" type="number" step="0.1" value="${p.h||1}" onchange="rebuildGeom()"></div>
      <div class="vf"><label>Ğ“</label><input class="ni" id="gd" type="number" step="0.1" value="${p.d||1}" onchange="rebuildGeom()"></div></div>`;
  } else if (obj.type==='sphere') {
    h=`<div class="plabel">ĞŸĞ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹</div><div class="v3">
      <div class="vf"><label>Ğ Ğ°Ğ´Ğ¸ÑƒÑ</label><input class="ni" id="gr" type="number" step="0.1" value="${p.r||0.5}" onchange="rebuildGeom()"></div>
      <div class="vf"><label>Ğ¡ĞµĞ³.W</label><input class="ni" id="gsw" type="number" step="1" value="${p.sw||32}" onchange="rebuildGeom()"></div>
      <div class="vf"><label>Ğ¡ĞµĞ³.H</label><input class="ni" id="gsh" type="number" step="1" value="${p.sh||16}" onchange="rebuildGeom()"></div></div>`;
  } else if (obj.type==='cyl') {
    h=`<div class="plabel">ĞŸĞ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹</div><div class="v3">
      <div class="vf"><label>R Ğ²ĞµÑ€Ñ…</label><input class="ni" id="grt" type="number" step="0.1" value="${p.rt||0.5}" onchange="rebuildGeom()"></div>
      <div class="vf"><label>R Ğ½Ğ¸Ğ·</label><input class="ni" id="grb" type="number" step="0.1" value="${p.rb||0.5}" onchange="rebuildGeom()"></div>
      <div class="vf"><label>Ğ’Ñ‹ÑĞ¾Ñ‚Ğ°</label><input class="ni" id="gch" type="number" step="0.1" value="${p.h||1}" onchange="rebuildGeom()"></div></div>`;
  } else if (obj.type==='cone') {
    h=`<div class="plabel">ĞŸĞ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹</div><div class="v3">
      <div class="vf"><label>Ğ Ğ°Ğ´Ğ¸ÑƒÑ</label><input class="ni" id="gcor" type="number" step="0.1" value="${p.r||0.5}" onchange="rebuildGeom()"></div>
      <div class="vf"><label>Ğ’Ñ‹ÑĞ¾Ñ‚Ğ°</label><input class="ni" id="gcoh" type="number" step="0.1" value="${p.h||1}" onchange="rebuildGeom()"></div>
      <div class="vf"><label>Ğ¡ĞµĞ³Ğ¼.</label><input class="ni" id="gcos" type="number" step="1" value="${p.s||32}" onchange="rebuildGeom()"></div></div>`;
  } else if (obj.type==='torus') {
    h=`<div class="plabel">ĞŸĞ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹</div><div class="v3">
      <div class="vf"><label>R</label><input class="ni" id="gtr" type="number" step="0.1" value="${p.r||0.5}" onchange="rebuildGeom()"></div>
      <div class="vf"><label>Ğ¢Ñ€ÑƒĞ±ĞºĞ°</label><input class="ni" id="gtt" type="number" step="0.05" value="${p.t||0.2}" onchange="rebuildGeom()"></div>
      <div class="vf"><label>Ğ¡ĞµĞ³Ğ¼.</label><input class="ni" id="gts" type="number" step="1" value="${p.s||32}" onchange="rebuildGeom()"></div></div>`;
  }
  el.innerHTML=h;
}

function rebuildGeom() {
  if (sel.length!==1) return;
  const obj=sel[0];
  saveUndo();
  const g=id=>{ const e=document.getElementById(id); return e?parseFloat(e.value):0; };
  const gi=id=>{ const e=document.getElementById(id); return e?parseInt(e.value):1; };
  let geom, params;
  if (obj.type==='box') {
    params={w:g('gw')||1,h:g('gh')||1,d:g('gd')||1};
    geom=new THREE.BoxGeometry(params.w,params.h,params.d);
  } else if (obj.type==='sphere') {
    params={r:g('gr')||0.5,sw:gi('gsw')||32,sh:gi('gsh')||16};
    geom=new THREE.SphereGeometry(params.r,params.sw,params.sh);
  } else if (obj.type==='cyl') {
    params={rt:g('grt')||0.5,rb:g('grb')||0.5,h:g('gch')||1};
    geom=new THREE.CylinderGeometry(params.rt,params.rb,params.h,32);
  } else if (obj.type==='cone') {
    params={r:g('gcor')||0.5,h:g('gcoh')||1,s:gi('gcos')||32};
    geom=new THREE.ConeGeometry(params.r,params.h,params.s);
  } else if (obj.type==='torus') {
    params={r:g('gtr')||0.5,t:g('gtt')||0.2,s:gi('gts')||32};
    geom=new THREE.TorusGeometry(params.r,params.t,16,params.s);
  }
  if (geom) { obj.mesh.geometry.dispose(); obj.mesh.geometry=geom; obj.params=params; updateStats(); }
}

// â”€â”€ Add Objects â”€â”€
function addObj(type) {
  saveUndo();
  const color=PALETTE[ci%PALETTE.length]; ci++;
  const mat=new THREE.MeshStandardMaterial({color:new THREE.Color(color),roughness:0.45,metalness:0});
  let geom, params;
  const names={box:'ĞšÑƒĞ±',sphere:'Ğ¡Ñ„ĞµÑ€Ğ°',cyl:'Ğ¦Ğ¸Ğ»Ğ¸Ğ½Ğ´Ñ€',cone:'ĞšĞ¾Ğ½ÑƒÑ',torus:'Ğ¢Ğ¾Ñ€',plane:'ĞŸĞ»Ğ¾ÑĞºĞ¾ÑÑ‚ÑŒ'};

  if (type==='box') { geom=new THREE.BoxGeometry(1,1,1); params={w:1,h:1,d:1}; }
  else if (type==='sphere') { geom=new THREE.SphereGeometry(0.5,32,16); params={r:0.5,sw:32,sh:16}; }
  else if (type==='cyl') { geom=new THREE.CylinderGeometry(0.5,0.5,1,32); params={rt:0.5,rb:0.5,h:1}; }
  else if (type==='cone') { geom=new THREE.ConeGeometry(0.5,1,32); params={r:0.5,h:1,s:32}; }
  else if (type==='torus') { geom=new THREE.TorusGeometry(0.5,0.2,16,32); params={r:0.5,t:0.2,s:32}; }
  else if (type==='plane') { geom=new THREE.PlaneGeometry(1,1); params={w:1,h:1}; }

  const mesh=new THREE.Mesh(geom,mat);
  mesh.castShadow=true; mesh.receiveShadow=true;
  mesh.position.set((Math.random()-.5)*.4, 0.5, (Math.random()-.5)*.4);
  scene.add(mesh);

  if (!counter[type]) counter[type]=0; counter[type]++;
  const obj={id:Date.now()+Math.random(),type,name:`${names[type]} ${counter[type]}`,mesh,params};
  objs.push(obj);
  updateTree(); updateStats();
  deselectAll(false); selectObj(obj,true);
  document.getElementById('empty-hint').style.display='none';
  closeAllMenus();
}

// â”€â”€ Scene Tree â”€â”€
function updateTree() {
  const tree=document.getElementById('tree-wrap');
  const icons={box:'â¬›',sphere:'ğŸ”µ',cyl:'ğŸ”·',cone:'ğŸ”º',torus:'â­•',plane:'â¬œ',imported:'ğŸ“¦',merged:'ğŸ”²'};
  tree.innerHTML=objs.map(o=>`
    <div class="tree-node ${sel.includes(o)?'sel':''} ${o.mesh&&!o.mesh.visible?'hidden-obj':''}"
         data-id="${o.id}" onclick="treeClick(event,${o.id})" ondblclick="treeDbClick(${o.id})">
      <span class="tn-ico">${icons[o.type]||'ğŸ“¦'}</span>
      <span class="tn-name">${o.name}</span>
      <span class="tn-eye" onclick="toggleVis(event,${o.id})">ğŸ‘</span>
    </div>`).join('');
  document.getElementById('obj-cnt').textContent=objs.length;
}

function treeClick(e,id) {
  const o=objs.find(x=>x.id===id); if(!o) return;
  if (e.shiftKey) toggleSel(o); else selectObj(o,true);
}
function treeDbClick(id) { const o=objs.find(x=>x.id===id); if(o) frameObjs([o.mesh]); }
function toggleVis(e,id) {
  e.stopPropagation();
  const o=objs.find(x=>x.id===id); if(!o) return;
  o.mesh.visible=!o.mesh.visible; updateTree();
}

// â”€â”€ Transform Panel â”€â”€
function applyTf() {
  if (sel.length!==1) return;
  const m=sel[0].mesh, r=THREE.MathUtils.degToRad;
  const g=id=>parseFloat(document.getElementById(id).value)||0;
  m.position.set(g('px'),g('py'),g('pz'));
  m.rotation.set(r(g('rx')),r(g('ry')),r(g('rz')));
  m.scale.set(g('sx')||1,g('sy')||1,g('sz')||1);
  showGizmoMesh();
}

function applyMat() {
  if (sel.length!==1) return;
  const mat=sel[0].mesh.material;
  mat.color.set(document.getElementById('mc').value);
  mat.metalness=+document.getElementById('mm').value;
  mat.roughness=+document.getElementById('mr').value;
  mat.opacity=+document.getElementById('mo').value;
  mat.transparent=mat.opacity<1;
  mat.needsUpdate=true;
}

function toggleWireObj() {
  if (sel.length!==1) return;
  const mat=sel[0].mesh.material;
  mat.wireframe=!mat.wireframe;
  document.getElementById('tog-wire').classList.toggle('on',mat.wireframe);
}

function rng(el,vid) { document.getElementById(vid).textContent=parseFloat(el.value).toFixed(2); }

// â”€â”€ Delete / Duplicate â”€â”€
function deleteSel() {
  if (!sel.length) return;
  saveUndo();
  sel.forEach(o=>{ scene.remove(o.mesh); o.mesh.geometry.dispose(); o.mesh.material.dispose(); objs.splice(objs.indexOf(o),1); });
  sel=[];
  hideGizmoMesh();
  updateTree(); updateStats(); updateSelUI();
  if (!objs.length) document.getElementById('empty-hint').style.display='block';
}

function duplicateSel() {
  if (!sel.length) return;
  saveUndo();
  const newObjs=[];
  sel.forEach(o=>{
    const ng=o.mesh.geometry.clone(), nm=o.mesh.material.clone();
    const mesh=new THREE.Mesh(ng,nm);
    mesh.castShadow=true; mesh.receiveShadow=true;
    mesh.position.copy(o.mesh.position).add(new THREE.Vector3(.5,0,.5));
    mesh.rotation.copy(o.mesh.rotation); mesh.scale.copy(o.mesh.scale);
    scene.add(mesh);
    const no={id:Date.now()+Math.random(),type:o.type,name:o.name+' (ĞºĞ¾Ğ¿Ğ¸Ñ)',mesh,params:{...o.params}};
    objs.push(no); newObjs.push(no);
  });
  deselectAll(false);
  newObjs.forEach(o=>{ sel.push(o); o.mesh.material.emissive=new THREE.Color(0x00d4ff); o.mesh.material.emissiveIntensity=0.12; });
  updateTree(); updateStats(); updateSelUI(); showGizmoMesh();
}

// â”€â”€ Framing â”€â”€
function frameSel() { if(sel.length) frameObjs(sel.map(o=>o.mesh)); else frameAll(); }
function frameAll() { if(objs.length) frameObjs(objs.map(o=>o.mesh)); }
function frameObjs(meshes) {
  const box=new THREE.Box3();
  meshes.forEach(m=>box.expandByObject(m));
  const size=box.getSize(new THREE.Vector3());
  orbit.target.copy(box.getCenter(new THREE.Vector3()));
  orbit.radius=Math.max(size.length()*1.8, 1.5);
  updateCam();
}

// â”€â”€ Stats â”€â”€
function updateStats() {
  let tris=0;
  objs.forEach(o=>{ const g=o.mesh.geometry; tris+=g.index?g.index.count/3:g.attributes.position.count/3; });
  document.getElementById('vp-stats').textContent=`ĞĞ±ÑŠĞµĞºÑ‚Ğ¾Ğ²: ${objs.length} | Ğ¢Ñ€Ğ¸Ñ: ${Math.round(tris).toLocaleString('ru')}`;
}

// â”€â”€ Grid / Wireframe â”€â”€
function toggleGrid() { gridOn=!gridOn; gridMesh.visible=gridOn; closeAllMenus(); }
function toggleWire() {
  wireOn=!wireOn;
  objs.forEach(o=>{ o.mesh.material.wireframe=wireOn; });
  closeAllMenus();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  VISUAL TRANSFORM GIZMO  â€” v4 (fully corrected)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
/*
  Colour convention (Blender / Maya standard):
    X  â†’  Red    #ff3355
    Y  â†’  Green  #33ff77
    Z  â†’  Blue   #3399ff
   XYZ â†’ White  (uniform scale)

  â”€â”€ Rings (Rotate mode) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  THREE.TorusGeometry() default: lies flat in XZ plane, normal = Y.

    X-ring  rotates obj around X  â†’  ring must stand in YZ plane  â†’  normal = X
            rotate torus  0, 0, PI/2   (tilt from Y-normal to X-normal)

    Y-ring  rotates obj around Y  â†’  ring lies in XZ plane        â†’  normal = Y
            no rotation needed (torus default already has normal Y in r128
            â€” wait, r128 TorusGeometry: lies in XY plane, normal = Z)

  Actually in Three.js r128:
    TorusGeometry default orientation: ring lies in XY plane, tube goes around X.
    Its "flat face" normal is +Z.

    To rotate around X  â†’  ring must be perpendicular to X  â†’  lie in YZ plane
       achieve: rotate torus 90Â° around Y  â†’  rotateY(PI/2)

    To rotate around Y  â†’  ring must be perpendicular to Y  â†’  lie in XZ plane
       achieve: rotate torus 90Â° around X  â†’  rotateX(PI/2)

    To rotate around Z  â†’  ring must be perpendicular to Z  â†’  lie in XY plane
       torus default = already in XY plane  â†’  no rotation

  â”€â”€ Screen-space axis projection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    1. Force gizmoRoot worldMatrix update before projecting.
    2. Project world origin + (origin + axis*1) â†’ NDC.
    3. Dot mouse NDC delta with projected axis direction.
    4. Scale = orbit.radius * constant for consistent feel.
*/

let gizmoMeshes   = {};
let gizmoRoot     = null;
let gizmoHovAxis  = null;   // highlighted axis key

// â”€â”€ Material helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function _mat(color, opacity) {
  opacity = (opacity === undefined) ? 1.0 : opacity;
  return new THREE.MeshBasicMaterial({
    color       : color,
    depthTest   : false,
    depthWrite  : false,
    transparent : (opacity < 1.0),
    opacity     : opacity,
  });
}
function _hitMat() {
  return new THREE.MeshBasicMaterial({
    transparent : true,
    opacity     : 0,
    depthTest   : false,
    depthWrite  : false,
    side        : THREE.DoubleSide,
  });
}

// â”€â”€ Arrow (Translate + Scale) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Built along local +Y, quaternion-rotated to worldDir.

function _buildArrow(parent, axisKey, color, worldDir, tipStyle) {
  // tipStyle: 'cone' for translate, 'box' for scale
  const g = new THREE.Group();

  // shaft
  const shaft = new THREE.Mesh(
    new THREE.CylinderGeometry(0.030, 0.030, 0.75, 12),
    _mat(color, 0.92)
  );
  shaft.position.y = 0.375;
  g.add(shaft);

  // tip
  if (tipStyle === 'cone') {
    const cone = new THREE.Mesh(
      new THREE.ConeGeometry(0.080, 0.22, 12),
      _mat(color, 1.0)
    );
    cone.position.y = 0.86;
    g.add(cone);
  } else {
    const box = new THREE.Mesh(
      new THREE.BoxGeometry(0.15, 0.15, 0.15),
      _mat(color, 1.0)
    );
    box.position.y = 0.83;
    g.add(box);
  }

  // fat invisible hit cylinder
  const hit = new THREE.Mesh(
    new THREE.CylinderGeometry(0.14, 0.14, 1.10, 10),
    _hitMat()
  );
  hit.position.y = 0.55;
  hit.userData.axis    = axisKey;
  hit.userData.isGizmo = true;
  g.add(hit);

  // orient: local +Y  â†’  worldDir
  const up = new THREE.Vector3(0, 1, 0);
  const dir = worldDir.clone().normalize();
  if (Math.abs(up.dot(dir)) > 0.9999) {
    // parallel â€” handle degenerate case
    if (dir.y < 0) g.rotation.z = Math.PI;
  } else {
    g.quaternion.setFromUnitVectors(up, dir);
  }

  parent.add(g);
  return hit;
}

// â”€â”€ Ring (Rotate) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Three.js r128: TorusGeometry lies in XY plane, normal = +Z.
//
//  X-ring (rotates around X):  ring normal must be +X
//    â†’ rotate  0, PI/2, 0   (rotate around Y to bring Zâ†’X)
//
//  Y-ring (rotates around Y):  ring normal must be +Y
//    â†’ rotate  PI/2, 0, 0   (rotate around X to bring Zâ†’Y â€¦ wait)
//    Actually rotX(PI/2): new Z = old Y direction. Hmm.
//    Let's think carefully:
//      default torus: normal = Z.  We want normal = Y.
//      Rotate -90Â° around X:  Z â†’ -Y? No.
//      Rotate +90Â° around X:  Y-axis: original Z (0,0,1) â†’ (0,-1,0). Not right.
//      Rotate -90Â° around X:  original Z (0,0,1) â†’ (0,1,0). YES.
//    â†’ rotate  -PI/2, 0, 0
//
//  Z-ring (rotates around Z):  ring normal must be +Z â†’ already there, no rotation.

function _buildRing(parent, axisKey, color, rx, ry, rz) {
  const RADIUS = 0.90;
  const TUBE   = 0.036;
  const HIT_TUBE = 0.13;
  const SEG  = 64;

  const ring = new THREE.Mesh(
    new THREE.TorusGeometry(RADIUS, TUBE, 10, SEG),
    _mat(color, 0.90)
  );
  ring.rotation.set(rx, ry, rz);
  ring.userData.axis    = axisKey;
  ring.userData.isGizmo = true;
  ring.renderOrder      = 1001;

  const hitRing = new THREE.Mesh(
    new THREE.TorusGeometry(RADIUS, HIT_TUBE, 8, SEG),
    _hitMat()
  );
  hitRing.rotation.set(rx, ry, rz);
  hitRing.userData.axis    = axisKey;
  hitRing.userData.isGizmo = true;

  parent.add(ring);
  parent.add(hitRing);
  return hitRing;
}

// â”€â”€ Build scene gizmo â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function buildGizmoMeshes() {
  if (gizmoRoot) { scene.remove(gizmoRoot); gizmoRoot = null; }
  gizmoMeshes = {};
  if (gizmoMode === 'none' || !sel.length) return;

  gizmoRoot = new THREE.Group();
  gizmoRoot.renderOrder = 999;

  if (gizmoMode === 'translate') {
    gizmoMeshes['x'] = _buildArrow(gizmoRoot, 'x', 0xff3355, new THREE.Vector3( 1,  0,  0), 'cone');
    gizmoMeshes['y'] = _buildArrow(gizmoRoot, 'y', 0x33ff77, new THREE.Vector3( 0,  1,  0), 'cone');
    gizmoMeshes['z'] = _buildArrow(gizmoRoot, 'z', 0x3399ff, new THREE.Vector3( 0,  0,  1), 'cone');

  } else if (gizmoMode === 'rotate') {
    //  X-ring: normal = X  â†’  rotate Y by +PI/2
    //  Y-ring: normal = Y  â†’  rotate X by -PI/2
    //  Z-ring: normal = Z  â†’  no rotation
    gizmoMeshes['x'] = _buildRing(gizmoRoot, 'x', 0xff3355,  0,          Math.PI/2, 0);
    gizmoMeshes['y'] = _buildRing(gizmoRoot, 'y', 0x33ff77, -Math.PI/2,  0,         0);
    gizmoMeshes['z'] = _buildRing(gizmoRoot, 'z', 0x3399ff,  0,          0,         0);

  } else if (gizmoMode === 'scale') {
    gizmoMeshes['x'] = _buildArrow(gizmoRoot, 'x', 0xff3355, new THREE.Vector3( 1,  0,  0), 'box');
    gizmoMeshes['y'] = _buildArrow(gizmoRoot, 'y', 0x33ff77, new THREE.Vector3( 0,  1,  0), 'box');
    gizmoMeshes['z'] = _buildArrow(gizmoRoot, 'z', 0x3399ff, new THREE.Vector3( 0,  0,  1), 'box');

    // centre white cube = uniform scale
    const uCube = new THREE.Mesh(
      new THREE.BoxGeometry(0.20, 0.20, 0.20),
      _mat(0xffffff, 0.95)
    );
    uCube.userData.axis    = 'xyz';
    uCube.userData.isGizmo = true;
    gizmoRoot.add(uCube);
    gizmoMeshes['xyz'] = uCube;
  }

  gizmoRoot.position.copy(sel[0].mesh.position);
  _scaleGizmoToCamera();
  scene.add(gizmoRoot);
  gizmoRoot.updateMatrixWorld(true);  // force so projections are correct immediately
}

function _scaleGizmoToCamera() {
  if (!gizmoRoot) return;
  const dist = camera.position.distanceTo(gizmoRoot.position);
  gizmoRoot.scale.setScalar(Math.max(0.01, dist * 0.10));
}

function updateGizmoMeshPosition() {
  if (!gizmoRoot) return;
  if (gizmoMode === 'none' || !sel.length) { gizmoRoot.visible = false; return; }
  gizmoRoot.visible = true;
  gizmoRoot.position.copy(sel[0].mesh.position);
  _scaleGizmoToCamera();
}

function showGizmoMesh() {
  if (gizmoMode !== 'none' && sel.length) buildGizmoMeshes();
}

function hideGizmoMesh() {
  if (gizmoRoot) { scene.remove(gizmoRoot); gizmoRoot = null; }
  gizmoMeshes = {};
}

// â”€â”€ Hit-test â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function hitTestGizmo() {
  if (!gizmoRoot || !gizmoRoot.visible) return null;
  raycaster.setFromCamera(mouse, camera);
  const hitMeshes = Object.values(gizmoMeshes).filter(Boolean);
  const hits = raycaster.intersectObjects(hitMeshes, true);
  if (!hits.length) return null;

  let obj = hits[0].object;
  while (obj) {
    if (obj.userData && obj.userData.isGizmo) return obj.userData.axis;
    obj = obj.parent;
  }
  return null;
}

// â”€â”€ Screen-space axis direction (used for translate & scale) â”€â”€â”€â”€â”€â”€

/*  Projects the world-space axis direction onto screen NDC so that
    dragging the mouse exactly along the arrow always feels correct.

    IMPORTANT: call gizmoRoot.updateMatrixWorld(true) before this
    so the world position is fresh.                                   */
function _screenAxisDir(worldAxisVec) {
  gizmoRoot.updateMatrixWorld(true);

  const origin = new THREE.Vector3().copy(gizmoRoot.position);
  const tip    = new THREE.Vector3().copy(gizmoRoot.position).addScaledVector(worldAxisVec, 1.0);

  const projectToNDC = (v) => {
    const c = v.clone().project(camera);
    return new THREE.Vector2(c.x, c.y);
  };

  const s0  = projectToNDC(origin);
  const s1  = projectToNDC(tip);
  const dir = new THREE.Vector2().subVectors(s1, s0);

  if (dir.lengthSq() < 1e-10) return new THREE.Vector2(1, 0);
  return dir.normalize();
}

// â”€â”€ Apply transform â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function applyGizmoTransform(e, rawDx, rawDy) {
  if (!sel.length || !gizmoAxis) return;
  const obj = sel[0];
  const vp  = document.getElementById('vp');
  const W   = vp.clientWidth;
  const H   = vp.clientHeight;

  // Convert pixel delta â†’ NDC delta
  //   NDC x: right = +1,  screen x: right = +pixel
  //   NDC y: up    = +1,  screen y: up    = -pixel  (Y inverted)
  const ndcDx =  rawDx / (W * 0.5);
  const ndcDy = -rawDy / (H * 0.5);
  const mDelta = new THREE.Vector2(ndcDx, ndcDy);

  // Sensitivity tuned so 1 NDC unit = 1 world unit * orbitRadius factor
  const tSpeed = orbit.radius * 1.6;   // translate
  const rSpeed = 4.0;                  // rotate  (rad per NDC unit)
  const sSpeed = 3.5;                  // scale

  const worldAxes = {
    x: new THREE.Vector3(1, 0, 0),
    y: new THREE.Vector3(0, 1, 0),
    z: new THREE.Vector3(0, 0, 1),
  };

  // â”€â”€ TRANSLATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (gizmoMode === 'translate') {
    const wAxis  = worldAxes[gizmoAxis];
    const sDir   = _screenAxisDir(wAxis);          // 2-D screen direction of the axis
    const dot    = mDelta.dot(sDir);               // signed: + means "along arrow"
    obj.mesh.position.addScaledVector(wAxis, dot * tSpeed);

  // â”€â”€ ROTATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  //  For each ring:
  //    - The ring is perpendicular to its axis.
  //    - The "drag direction" that feels natural is the ring's tangent on screen.
  //    - We compute the screen projection of the axis,
  //      then rotate that 90Â° to get the tangent direction.
  //    - Dot mouse delta with tangent â†’ signed angle delta.
  //
  //  Sign convention: dragging counter-clockwise (as you look at the ring face-on)
  //  should give POSITIVE rotation (right-hand rule around the axis pointing at you).
  //
  //  The dot product naturally gives the right sign because:
  //    - _screenAxisDir points toward "positive axis" on screen.
  //    - tangent = rotate screenAxisDir by 90Â° CCW = (-y, x).
  //    - If you drag CCW (matching the tangent), dot > 0 â†’ angle increases.
  //    - Three.js rotation is right-hand: positive = CCW when axis points at you. âœ“
  } else if (gizmoMode === 'rotate') {
    const wAxis   = worldAxes[gizmoAxis];
    const sDir    = _screenAxisDir(wAxis);
    // 90Â° CCW rotation in screen space: (x,y) â†’ (-y, x)
    const tangent = new THREE.Vector2(-sDir.y, sDir.x);
    const dot     = mDelta.dot(tangent);

    if      (gizmoAxis === 'x') obj.mesh.rotation.x += dot * rSpeed;
    else if (gizmoAxis === 'y') obj.mesh.rotation.y += dot * rSpeed;
    else if (gizmoAxis === 'z') obj.mesh.rotation.z += dot * rSpeed;

  // â”€â”€ SCALE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  } else if (gizmoMode === 'scale') {
    if (gizmoAxis === 'xyz') {
      // Uniform: drag UP â†’ bigger.  rawDy: up = negative pixels â†’ negate.
      const factor = 1.0 + (-rawDy / H) * sSpeed * 2.0;
      obj.mesh.scale.multiplyScalar(Math.max(0.001, factor));
    } else {
      const wAxis  = worldAxes[gizmoAxis];
      const sDir   = _screenAxisDir(wAxis);
      const dot    = mDelta.dot(sDir);
      const factor = 1.0 + dot * sSpeed;
      if      (gizmoAxis === 'x') obj.mesh.scale.x = Math.max(0.001, obj.mesh.scale.x * factor);
      else if (gizmoAxis === 'y') obj.mesh.scale.y = Math.max(0.001, obj.mesh.scale.y * factor);
      else if (gizmoAxis === 'z') obj.mesh.scale.z = Math.max(0.001, obj.mesh.scale.z * factor);
    }
  }

  updatePropsPanel();
  // reposition without full rebuild
  if (gizmoRoot) {
    gizmoRoot.position.copy(obj.mesh.position);
    gizmoRoot.updateMatrixWorld(true);
  }
}

// â”€â”€ Tool / Gizmo Mode â”€â”€
function setTool(t) {
  activeTool=t;
  document.querySelectorAll('.tb-btn').forEach(b=>b.classList.remove('active'));
  document.getElementById('tbb-'+t)?.classList.add('active');
  const map={sel:'none',move:'translate',rot:'rotate',scale:'scale'};
  setGizmoMode(map[t]||'none');
}

function setGizmoMode(m) {
  gizmoMode=m;
  document.querySelectorAll('.tm-btn').forEach(b=>b.classList.remove('active'));
  document.getElementById('tmb-'+m)?.classList.add('active');
  hideGizmoMesh();
  if (m!=='none' && sel.length) buildGizmoMeshes();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BOOLEAN OPERATIONS (Geometry merging + approximation)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function boolOp(type) {
  if (sel.length<2) { toast('Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ 2 Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ° (Shift+ĞºĞ»Ğ¸Ğº)'); return; }
  saveUndo();
  const A=sel[0], B=sel[1];

  if (type==='union') {
    performUnion(A, B);
  } else if (type==='subtract') {
    performSubtract(A, B);
  } else if (type==='intersect') {
    performIntersect(A, B);
  }
}

function getWorldGeom(obj) {
  const g = obj.mesh.geometry.clone();
  g.applyMatrix4(obj.mesh.matrixWorld);
  g.computeVertexNormals();
  return g;
}

function performUnion(A, B) {
  // Merge both geometries
  const gA = getWorldGeom(A);
  const gB = getWorldGeom(B);
  const merged = mergeGeoms(gA, gB);
  merged.computeVertexNormals();
  
  const mat = A.mesh.material.clone();
  const mesh = new THREE.Mesh(merged, mat);
  mesh.castShadow=true; mesh.receiveShadow=true;
  scene.add(mesh);
  const no={id:Date.now(),type:'merged',name:`${A.name} âˆª ${B.name}`,mesh,params:{}};
  
  removeObjs([A,B]);
  objs.push(no);
  deselectAll(false); selectObj(no,true);
  updateTree(); updateStats();
  toast('ĞĞ±ÑŠĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¾');
}

function performSubtract(A, B) {
  // Approximate subtraction: keep A geometry, add B's inverted faces
  // This is a visual approximation - flip normals of B and merge
  const gA = getWorldGeom(A);
  const gB = getWorldGeom(B);
  flipNormals(gB);
  const merged = mergeGeoms(gA, gB);
  merged.computeVertexNormals();
  
  const mat = A.mesh.material.clone();
  const mesh = new THREE.Mesh(merged, mat);
  mesh.castShadow=true; mesh.receiveShadow=true;
  mesh.material.side = THREE.DoubleSide;
  scene.add(mesh);
  const no={id:Date.now(),type:'merged',name:`${A.name} âˆ’ ${B.name}`,mesh,params:{}};
  
  removeObjs([A,B]);
  objs.push(no);
  deselectAll(false); selectObj(no,true);
  updateTree(); updateStats();
  toast('Ğ’Ñ‹Ñ‡Ğ¸Ñ‚Ğ°Ğ½Ğ¸Ğµ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¾');
}

function performIntersect(A, B) {
  // Visual: scale B down slightly, merge
  const gA = getWorldGeom(A);
  const gB = getWorldGeom(B);
  
  // Scale B geometry to show overlap region
  const m = new THREE.Matrix4().makeScale(0.9,0.9,0.9);
  gB.applyMatrix4(m);
  
  const merged = mergeGeoms(gA, gB);
  merged.computeVertexNormals();
  
  const mat = B.mesh.material.clone();
  const mesh = new THREE.Mesh(merged, mat);
  mesh.castShadow=true; mesh.receiveShadow=true;
  scene.add(mesh);
  const no={id:Date.now(),type:'merged',name:`${A.name} âˆ© ${B.name}`,mesh,params:{}};
  
  removeObjs([A,B]);
  objs.push(no);
  deselectAll(false); selectObj(no,true);
  updateTree(); updateStats();
  toast('ĞŸĞµÑ€ĞµÑĞµÑ‡ĞµĞ½Ğ¸Ğµ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¾');
}

function flipNormals(geom) {
  const idx = geom.index;
  if (idx) {
    for (let i=0;i<idx.count;i+=3) {
      const a=idx.getX(i+1), b=idx.getX(i+2);
      idx.setX(i+1,b); idx.setX(i+2,a);
    }
    idx.needsUpdate=true;
  } else {
    const pos = geom.attributes.position.array;
    for (let i=0;i<pos.length;i+=9) {
      let tmp;
      tmp=pos[i+3]; pos[i+3]=pos[i+6]; pos[i+6]=tmp;
      tmp=pos[i+4]; pos[i+4]=pos[i+7]; pos[i+7]=tmp;
      tmp=pos[i+5]; pos[i+5]=pos[i+8]; pos[i+8]=tmp;
    }
    geom.attributes.position.needsUpdate=true;
  }
}

function mergeGeoms(gA, gB) {
  // Convert both to non-indexed for simpler merge
  const a = gA.index ? gA.toNonIndexed() : gA;
  const b = gB.index ? gB.toNonIndexed() : gB;
  
  const posA=a.attributes.position.array, posB=b.attributes.position.array;
  const norA=a.attributes.normal?a.attributes.normal.array:new Float32Array(posA.length);
  const norB=b.attributes.normal?b.attributes.normal.array:new Float32Array(posB.length);
  
  const positions=new Float32Array(posA.length+posB.length);
  const normals=new Float32Array(norA.length+norB.length);
  positions.set(posA); positions.set(posB,posA.length);
  normals.set(norA); normals.set(norB,norA.length);
  
  const g=new THREE.BufferGeometry();
  g.setAttribute('position',new THREE.BufferAttribute(positions,3));
  g.setAttribute('normal',new THREE.BufferAttribute(normals,3));
  return g;
}

function removeObjs(list) {
  list.forEach(o=>{ scene.remove(o.mesh); o.mesh.geometry.dispose(); o.mesh.material.dispose(); objs.splice(objs.indexOf(o),1); });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UNDO / REDO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function snapshot() {
  return objs.map(o=>({
    id:o.id, type:o.type, name:o.name, params:{...o.params},
    pos:o.mesh.position.toArray(),
    rot:[o.mesh.rotation.x,o.mesh.rotation.y,o.mesh.rotation.z],
    scl:o.mesh.scale.toArray(),
    color:'#'+o.mesh.material.color.getHexString(),
    metalness:o.mesh.material.metalness,
    roughness:o.mesh.material.roughness,
    opacity:o.mesh.material.opacity,
    wireframe:o.mesh.material.wireframe,
  }));
}

function restoreSnapshot(state) {
  objs.forEach(o=>{ scene.remove(o.mesh); o.mesh.geometry.dispose(); o.mesh.material.dispose(); });
  objs=[]; sel=[]; hideGizmoMesh();
  
  state.forEach(s=>{
    let g;
    const p=s.params;
    if (s.type==='box') g=new THREE.BoxGeometry(p.w||1,p.h||1,p.d||1);
    else if (s.type==='sphere') g=new THREE.SphereGeometry(p.r||0.5,p.sw||32,p.sh||16);
    else if (s.type==='cyl') g=new THREE.CylinderGeometry(p.rt||0.5,p.rb||0.5,p.h||1,32);
    else if (s.type==='cone') g=new THREE.ConeGeometry(p.r||0.5,p.h||1,p.s||32);
    else if (s.type==='torus') g=new THREE.TorusGeometry(p.r||0.5,p.t||0.2,16,p.s||32);
    else if (s.type==='plane') g=new THREE.PlaneGeometry(p.w||1,p.h||1);
    else g=new THREE.BoxGeometry(1,1,1);
    
    const mat=new THREE.MeshStandardMaterial({color:new THREE.Color(s.color),metalness:s.metalness||0,roughness:s.roughness||0.5,opacity:s.opacity!==undefined?s.opacity:1,transparent:(s.opacity||1)<1,wireframe:s.wireframe||false});
    const mesh=new THREE.Mesh(g,mat);
    mesh.castShadow=true; mesh.receiveShadow=true;
    mesh.position.fromArray(s.pos); mesh.rotation.set(...s.rot); mesh.scale.fromArray(s.scl);
    scene.add(mesh);
    objs.push({id:s.id,type:s.type,name:s.name,mesh,params:{...s.params}});
  });
  
  updateTree(); updateStats(); updateSelUI();
  document.getElementById('empty-hint').style.display=objs.length===0?'block':'none';
}

function saveUndo() {
  undoStack.push(snapshot());
  if (undoStack.length>50) undoStack.shift();
  redoStack=[];
}

function undo() {
  if (!undoStack.length) return;
  redoStack.push(snapshot());
  restoreSnapshot(undoStack.pop());
}

function redo() {
  if (!redoStack.length) return;
  undoStack.push(snapshot());
  restoreSnapshot(redoStack.pop());
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EXPORT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function exportSTL() {
  if (!objs.length) { toast('ĞĞµÑ‚ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ¾Ğ²'); return; }
  const targets = sel.length?sel:objs;
  let stl='solid ren3d\n';
  
  targets.forEach(obj=>{
    const g=obj.mesh.geometry.clone();
    g.applyMatrix4(obj.mesh.matrixWorld);
    g.computeVertexNormals();
    const gi=g.index?g.toNonIndexed():g;
    const pos=gi.attributes.position, nor=gi.attributes.normal;
    const n=pos.count;
    for(let i=0;i<n;i+=3){
      const nx=nor?nor.getX(i):0, ny=nor?nor.getY(i):1, nz=nor?nor.getZ(i):0;
      stl+=`  facet normal ${nx.toFixed(6)} ${ny.toFixed(6)} ${nz.toFixed(6)}\n    outer loop\n`;
      for(let v=0;v<3;v++) stl+=`      vertex ${pos.getX(i+v).toFixed(6)} ${pos.getY(i+v).toFixed(6)} ${pos.getZ(i+v).toFixed(6)}\n`;
      stl+=`    endloop\n  endfacet\n`;
    }
  });
  stl+='endsolid ren3d';
  download('ren3d.stl',stl);
  toast('Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ .stl Ğ³Ğ¾Ñ‚Ğ¾Ğ²!');
  closeAllMenus();
}

function exportOBJ() {
  if (!objs.length) { toast('ĞĞµÑ‚ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ¾Ğ²'); return; }
  const targets=sel.length?sel:objs;
  let obj='# Ren3D v2.0\n\n';
  let off=1;
  
  targets.forEach((o,i)=>{
    const g=o.mesh.geometry.clone();
    g.applyMatrix4(o.mesh.matrixWorld);
    g.computeVertexNormals();
    const gi=g.index?g.toNonIndexed():g;
    const pos=gi.attributes.position, nor=gi.attributes.normal;
    obj+=`g ${o.name.replace(/ /g,'_')}\n`;
    for(let v=0;v<pos.count;v++) obj+=`v ${pos.getX(v).toFixed(6)} ${pos.getY(v).toFixed(6)} ${pos.getZ(v).toFixed(6)}\n`;
    if(nor) for(let v=0;v<nor.count;v++) obj+=`vn ${nor.getX(v).toFixed(6)} ${nor.getY(v).toFixed(6)} ${nor.getZ(v).toFixed(6)}\n`;
    for(let v=0;v<pos.count;v+=3){
      const a=v+off,b=v+1+off,c=v+2+off;
      obj+=nor?`f ${a}//${a} ${b}//${b} ${c}//${c}\n`:`f ${a} ${b} ${c}\n`;
    }
    off+=pos.count; obj+='\n';
  });
  download('ren3d.obj',obj);
  toast('Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ .obj Ğ³Ğ¾Ñ‚Ğ¾Ğ²!');
  closeAllMenus();
}

function download(name,content) {
  const a=document.createElement('a');
  a.href=URL.createObjectURL(new Blob([content],{type:'text/plain'}));
  a.download=name; a.click();
  URL.revokeObjectURL(a.href);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  IMPORT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function doImport() { document.getElementById('file-in').click(); closeAllMenus(); }

function handleFile(e) {
  const f=e.target.files[0]; if(!f) return;
  const ext=f.name.split('.').pop().toLowerCase();
  const r=new FileReader();
  r.onload=ev=>{
    try {
      if(ext==='stl') importSTL(ev.target.result,f.name);
      else if(ext==='obj') importOBJ(ev.target.result,f.name);
      toast(`Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾: ${f.name}`);
    } catch(er){ toast('ĞÑˆĞ¸Ğ±ĞºĞ°: '+er.message); }
  };
  ext==='stl'?r.readAsArrayBuffer(f):r.readAsText(f);
  e.target.value='';
}

function importSTL(buf,name) {
  saveUndo();
  let g;
  const arr=new Uint8Array(buf,0,Math.min(80,buf.byteLength));
  const isAscii=!arr.some(b=>b>127);
  
  if (isAscii) {
    g=parseSTLASCII(new TextDecoder().decode(buf));
  } else {
    g=parseSTLBin(buf);
  }
  g.computeVertexNormals(); g.computeBoundingBox(); g.center();
  
  const mat=new THREE.MeshStandardMaterial({color:new THREE.Color(PALETTE[ci%PALETTE.length]),roughness:0.45,metalness:0});
  ci++;
  const mesh=new THREE.Mesh(g,mat);
  mesh.castShadow=true; mesh.receiveShadow=true; mesh.position.y=0.5;
  scene.add(mesh);
  const no={id:Date.now(),type:'imported',name:name.replace('.stl',''),mesh,params:{}};
  objs.push(no);
  updateTree(); updateStats();
  deselectAll(false); selectObj(no,true); frameObjs([mesh]);
  document.getElementById('empty-hint').style.display='none';
}

function parseSTLASCII(txt) {
  const verts=[],norms=[];
  let nx=0,ny=0,nz=0;
  for (const ln of txt.split('\n')) {
    const t=ln.trim();
    if(t.startsWith('facet normal')){const p=t.split(/\s+/);nx=+p[2];ny=+p[3];nz=+p[4];}
    else if(t.startsWith('vertex')){const p=t.split(/\s+/);verts.push(+p[1],+p[2],+p[3]);norms.push(nx,ny,nz);}
  }
  const g=new THREE.BufferGeometry();
  g.setAttribute('position',new THREE.BufferAttribute(new Float32Array(verts),3));
  g.setAttribute('normal',new THREE.BufferAttribute(new Float32Array(norms),3));
  return g;
}

function parseSTLBin(buf) {
  const view=new DataView(buf);
  const nf=view.getUint32(80,true);
  const verts=new Float32Array(nf*9), norms=new Float32Array(nf*9);
  let off=84;
  for(let i=0;i<nf;i++){
    const nx=view.getFloat32(off,true),ny=view.getFloat32(off+4,true),nz=view.getFloat32(off+8,true);
    off+=12;
    for(let v=0;v<3;v++){
      const vi=i*9+v*3;
      verts[vi]=view.getFloat32(off,true); verts[vi+1]=view.getFloat32(off+4,true); verts[vi+2]=view.getFloat32(off+8,true);
      norms[vi]=nx; norms[vi+1]=ny; norms[vi+2]=nz;
      off+=12;
    }
    off+=2;
  }
  const g=new THREE.BufferGeometry();
  g.setAttribute('position',new THREE.BufferAttribute(verts,3));
  g.setAttribute('normal',new THREE.BufferAttribute(norms,3));
  return g;
}

function importOBJ(txt,name) {
  saveUndo();
  const verts=[],norms=[],fverts=[],fnorms=[];
  for (const ln of txt.split('\n')) {
    const t=ln.trim();
    if(t.startsWith('v ')){const p=t.split(/\s+/);verts.push([+p[1],+p[2],+p[3]]);}
    else if(t.startsWith('vn ')){const p=t.split(/\s+/);norms.push([+p[1],+p[2],+p[3]]);}
    else if(t.startsWith('f ')){
      const parts=t.split(/\s+/).slice(1).map(p=>{const x=p.split('/');return{v:+x[0]-1,n:x[2]?+x[2]-1:-1};});
      for(let i=1;i<parts.length-1;i++){
        [parts[0],parts[i],parts[i+1]].forEach(fv=>{
          fverts.push(...(verts[fv.v]||[0,0,0]));
          fnorms.push(...(fv.n>=0&&norms[fv.n]?norms[fv.n]:[0,1,0]));
        });
      }
    }
  }
  const g=new THREE.BufferGeometry();
  g.setAttribute('position',new THREE.BufferAttribute(new Float32Array(fverts),3));
  g.setAttribute('normal',new THREE.BufferAttribute(new Float32Array(fnorms),3));
  g.computeVertexNormals(); g.computeBoundingBox(); g.center();
  
  const mat=new THREE.MeshStandardMaterial({color:new THREE.Color(PALETTE[ci%PALETTE.length]),roughness:0.45,metalness:0});
  ci++;
  const mesh=new THREE.Mesh(g,mat);
  mesh.castShadow=true; mesh.receiveShadow=true; mesh.position.y=0.5;
  scene.add(mesh);
  const no={id:Date.now(),type:'imported',name:name.replace('.obj',''),mesh,params:{}};
  objs.push(no);
  updateTree(); updateStats();
  deselectAll(false); selectObj(no,true); frameObjs([mesh]);
  document.getElementById('empty-hint').style.display='none';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  NEW SCENE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function newScene() {
  if (objs.length && !confirm('Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²ÑƒÑ ÑÑ†ĞµĞ½Ñƒ? Ğ˜Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ Ğ±ÑƒĞ´ÑƒÑ‚ Ğ¿Ğ¾Ñ‚ĞµÑ€ÑĞ½Ñ‹.')) return;
  objs.forEach(o=>{ scene.remove(o.mesh); o.mesh.geometry.dispose(); o.mesh.material.dispose(); });
  objs=[]; sel=[]; undoStack=[]; redoStack=[]; hideGizmoMesh();
  updateTree(); updateStats(); updateSelUI();
  document.getElementById('empty-hint').style.display='block';
  closeAllMenus();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  KEYBOARD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function onKey(e) {
  if (e.target.tagName==='INPUT') return;
  if (e.ctrlKey||e.metaKey) {
    switch(e.key.toLowerCase()) {
      case 'z': e.preventDefault(); undo(); break;
      case 'y': e.preventDefault(); redo(); break;
      case 'd': e.preventDefault(); duplicateSel(); break;
      case 'a': e.preventDefault(); selectAll(); break;
      case 'i': e.preventDefault(); doImport(); break;
      case 'e': e.preventDefault(); exportSTL(); break;
      case 'n': e.preventDefault(); newScene(); break;
    }
    return;
  }
  if (e.shiftKey) {
    switch(e.key.toLowerCase()) {
      case 'c': addObj('box'); break;
      case 's': addObj('sphere'); break;
      case 'y': addObj('cyl'); break;
      case 'o': addObj('cone'); break;
      case 't': addObj('torus'); break;
      case 'p': addObj('plane'); break;
    }
    return;
  }
  switch(e.key) {
    case 'Delete': case 'Backspace': deleteSel(); break;
    case 'Escape': deselectAll(); break;
    case 'f': case 'F': frameSel(); break;
    case 'g': toggleGrid(); break;
    case 'z': toggleWire(); break;
    case 'q': case 'Q': setTool('sel'); break;
    case 'G': setTool('move'); break;
    case 'r': case 'R': setTool('rot'); break;
    case 's': setTool('scale'); break;
    case 'Home': frameAll(); break;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ORIENTATION GIZMO (canvas corner)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function drawOriGizmo() {
  const cvs=document.getElementById('gizmo-cnv');
  const ctx=cvs.getContext('2d');
  const W=cvs.width, H=cvs.height, cx=W/2, cy=H/2, r=W/2-6;
  ctx.clearRect(0,0,W,H);

  ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2);
  ctx.fillStyle='rgba(5,5,8,0.55)'; ctx.fill();
  ctx.strokeStyle='rgba(255,255,255,0.06)'; ctx.lineWidth=1; ctx.stroke();

  const mat=new THREE.Matrix4().extractRotation(camera.matrixWorldInverse);
  const axes=[
    {v:new THREE.Vector3(1,0,0),c:'#ff4466',l:'X'},
    {v:new THREE.Vector3(0,1,0),c:'#44ff88',l:'Y'},
    {v:new THREE.Vector3(0,0,1),c:'#4499ff',l:'Z'},
    {v:new THREE.Vector3(-1,0,0),c:'#882233',l:''},
    {v:new THREE.Vector3(0,-1,0),c:'#226644',l:''},
    {v:new THREE.Vector3(0,0,-1),c:'#224488',l:''},
  ];
  const proj=axes.map(a=>{
    const v=a.v.clone().applyMatrix4(mat);
    return {x:cx+v.x*r*.8,y:cy-v.y*r*.8,z:v.z,c:a.c,l:a.l};
  }).sort((a,b)=>a.z-b.z);

  proj.forEach(p=>{
    ctx.globalAlpha=p.z>0?1:0.35;
    ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(p.x,p.y);
    ctx.strokeStyle=p.c; ctx.lineWidth=p.z>0?2:1; ctx.stroke();
    ctx.beginPath(); ctx.arc(p.x,p.y,4,0,Math.PI*2);
    ctx.fillStyle=p.c; ctx.fill();
    if(p.l){ ctx.fillStyle='rgba(255,255,255,0.85)'; ctx.font=`${p.z>0?'bold ':''}7px Fira Code`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(p.l,p.x,p.y); }
    ctx.globalAlpha=1;
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MENUS / UI HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function openMenu(name, btn) {
  const dd=document.getElementById('dd-'+name);
  const wasOpen=dd.classList.contains('open');
  closeAllMenus();
  if (!wasOpen) { dd.classList.add('open'); btn.classList.add('open'); }
  event.stopPropagation();
}

function closeMenus() { closeAllMenus(); }
function closeAllMenus() {
  document.querySelectorAll('.dropdown').forEach(d=>d.classList.remove('open'));
  document.querySelectorAll('.menu-trigger').forEach(b=>b.classList.remove('open'));
}

function toggleSec(hdr) {
  const body=hdr.nextElementSibling;
  if(!body) return;
  const hidden=body.style.display==='none';
  body.style.display=hidden?'':' none';
  if(!hidden) body.style.display='none';
  hdr.classList.toggle('coll',!hidden);
}

// Context menu
function onCtx(e) {
  e.preventDefault();
  updateMouse(e);
  raycaster.setFromCamera(mouse,camera);
  const hits=raycaster.intersectObjects(objs.map(o=>o.mesh));
  
  const items=hits.length?`
    <div class="ctx-it" onclick="duplicateSel();closeCtx()">Ğ”ÑƒĞ±Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ <span style="color:var(--ink-dim)">Ctrl+D</span></div>
    <div class="ctx-it" onclick="frameSel();closeCtx()">Ğ¤Ğ¾ĞºÑƒÑ <span style="color:var(--ink-dim)">F</span></div>
    <div class="ctx-sep"></div>
    <div class="ctx-it danger" onclick="deleteSel();closeCtx()">Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ <span style="color:var(--ink-dim)">Del</span></div>
  `:`
    <div class="ctx-it" onclick="addObj('box');closeCtx()">â¬› Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ ĞºÑƒĞ±</div>
    <div class="ctx-it" onclick="addObj('sphere');closeCtx()">ğŸ”µ Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑÑ„ĞµÑ€Ñƒ</div>
    <div class="ctx-it" onclick="addObj('cyl');closeCtx()">ğŸ”· Ğ¦Ğ¸Ğ»Ğ¸Ğ½Ğ´Ñ€</div>
    <div class="ctx-sep"></div>
    <div class="ctx-it" onclick="doImport();closeCtx()">â‡ª Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚ Ğ¼Ğ¾Ğ´ĞµĞ»Ğ¸</div>
  `;
  
  let ctx=document.getElementById('ren-ctx');
  if(!ctx){ctx=document.createElement('div');ctx.className='ctx';ctx.id='ren-ctx';document.body.appendChild(ctx);}
  ctx.innerHTML=items;
  ctx.style.left=Math.min(e.clientX,window.innerWidth-180)+'px';
  ctx.style.top=Math.min(e.clientY,window.innerHeight-160)+'px';
  ctx.style.display='block';
  setTimeout(()=>document.addEventListener('click',closeCtx,{once:true}),50);
}

function closeCtx() { const c=document.getElementById('ren-ctx'); if(c) c.style.display='none'; }

// Toast
let toastTimer;
function toast(msg) {
  const el=document.getElementById('toast');
  el.textContent=msg; el.style.opacity='1';
  clearTimeout(toastTimer);
  toastTimer=setTimeout(()=>el.style.opacity='0',2800);
}

// â”€â”€ Start â”€â”€
window.addEventListener('load', init);
window.addEventListener('resize', resize);
</script>
</body>
</html>
